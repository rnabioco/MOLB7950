---
title: "ChIP Class 1"
author: "Srinivas Ramachandran"
date: "9/18/2020"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(engine.opts = list(bash= "-l"))
```

## Fun recap

Assume the following parameters from a ChIP experiment in human cells:

1.  On average, a peak is 10 fold enriched relative to the background.
2.  There are 20,000 peaks of width 500 bp

What proportion of reads in the dataset would arise from peaks?

Total genome size = 3.3x10\^9 bp How many bases covered by peaks = 20,000\*500

Fraction = 20000\*500\*10/(3.3\*10\^9)

# Learning objectives

Get an idea of how data from the sequencer is processed for ChIP/CUT&RUN experiments so that it can be viewed in the genome browser and be used for peak calling and further analyses.

# CUT&RUN Analysis

Any paired-end sequencing data gives us fastq files. Here, we are not interested in the sequence itself, but the length of the fragments we have sequenced and where the fragments align in the genome. So we want to build a pipeline first to get the start and end positions of each fragment that we sequenced.

After alignment, we will get a SAM file. Read about the SAM format here: <https://samtools.github.io/hts-specs/SAMv1.pdf>

For analysis of ChIP/DNase/ATAC/CUT&RUN, bowtie2 is a great aligner. Here is an example bowtie2 command:

```         
bowtie2 --local --very-sensitive-local --no-unal --no-mixed --no-discordant -q --phred33 -I 10 -X 700 --threads 12 -x lib/bowtie2/dm3/genome -1 R1.fastq -2 R2.fastq > Output.sam
```

-   Here R1.fastq and R2.fastq are the files we got from sequencing.

-   Output.sam contains the alignments.

-   "lib/bowtie2/dm3/genome" is the prefix of the genome index files for the "dm3" version of the *Drosophila* genome.

For this class, we will use a sam file generated by bowtie2 in a small subset of the *Drosophila* genome. Some key points about the experiment:

CUT&RUN Factor: Trl or GAGA Factor (GAF)

*Drosophila* genome version: dm3

### What to do with repeats?

We are fundamentally asking how many reads map at any position in the genome and interpret regions with high read density as the locations where the factor of our interest binds.

#### What is the expectation when aligning reads to repetitive regions in the reference genome? (Think telomeres)

To filter out reads that map to multiple places in the genome, we will use a nifty flag that bowtie2 places in the SAM file: XS.

How many reads in our SAM file align to multiple regions?

```{bash}
#How does a sam entry with XS look?
grep "XS:" data/Trl_CR_subset.sam | head -n 1
#How many reads align to multiple regions?
grep -c "XS:" data/Trl_CR_subset.sam
```

Let us remove these reads from our SAM file:

```{bash}
grep -v "XS:" data/Trl_CR_subset.sam > data/Trl_CR_subset_uniq.sam
```

Now, since we want only the fragment start and end positions, we don't have to deal with SAM files. So first let us convert the SAM file into a bedpe file. bedpe file has information of both "mates" of a paired-end read.

We will use bedtools to do this. But, bedtools needs a bam file as an input. What is a "bam" file?

We will convert sam to bam using "view" function of samtools:

```{bash    }
samtools view -bf 0x2 data/Trl_CR_subset_uniq.sam | bedtools bamtobed -i stdin -bedpe > data/Trl_CR_subset.bedpe
```

Let us take a look at the bedpe format:

```{bash}
head -n 5 data/Trl_CR_subset.bedpe | awk '{print "LINE NO.",NR,$0}'
```

## How to get just the fragment ends? (Cue: some diagrams)

We will use a perl script I wrote to get just the fragment ends:

```{bash eval=FALSE, include=FALSE}
perl code/bedpe2bed.pl 
```

```{bash}
perl code/bedpe2bed.pl data/Trl_CR_subset.bedpe > data/Trl_CR_subset.bed
```

## What is the format of this new bed file?

```{bash}
head data/Trl_CR_subset.bed
```

-   First column is the chromosome
-   Second column is the start position of the sequenced fragment
-   Third column is the end position of the sequenced fragment
-   Fourth column is the fragment length

## What is the distribution of the fragment lengths?

```{r}
bed_file <- read.csv(file='data/Trl_CR_subset.bed',header=F,sep='\t')
colnames(bed_file) <- c('chr','start','end','length','jnk','strand')
hist(bed_file$length,breaks=150)
```

In CUT&RUN, fragments less than 120 bp represent transcription factor binding and fragments greater than 120 bp represent nucleosome binding around the transcription factor. We will analyze these two subsets of fragments separately from now on.

## Calculate read density

Next, we will pile up the reads and count the number of reads that overlap each 10 bp window. We will create a wiggle file for read densities. Read about the wiggle format here: <http://genome.ucsc.edu/goldenPath/help/wiggle>

We will use a perl script I wrote for converting bed file to wig file. You can write your own script in python too.

```{bash eval=FALSE, include=FALSE}
perl code/bed2wig.pl
```

```{bash}
perl code/bed2wig.pl data/Trl_CR_subset.bed data/Trl_CR_lt_120.wig 0 120 10 dm3
perl code/bed2wig.pl data/Trl_CR_subset.bed data/Trl_CR_gt_120.wig 121 300 10 dm3
```

How do the wig files we generated look like?

```{bash}
head data/Trl_CR_lt_120.wig
```

Next we will call peaks to identify where Trl binds in the genome. But before calling peaks, we will learn how to visualize wig files, to get an intuitive sense of the data.

## Visualize the read density (wig file)

We will use rtracklayer and Gviz library from bioconductor to do this.

```{r message=F}
library('rtracklayer')
library('Gviz')
```

We will compress wig files into bigwigs (similar to sam-\>bam). We will use bigwig files for read densities inside R.

```{r}
dm3 <- SeqinfoForUCSCGenome('dm3')
wigToBigWig('data/Trl_CR_lt_120.wig',seqinfo = dm3,dest = 'data/Trl_CR_lt_120.bw')
wigToBigWig('data/Trl_CR_gt_120.wig',seqinfo = dm3,dest = 'data/Trl_CR_gt_120.bw')
```

-   We can extract the gene annotations from UCSC (The other option is to load from Biomart).

-   Genome axis will enable plotting genomic coordinates as a separate axis.

-   Ideogram represents the chromosome structure and helps identify relative location on the chromosome.

```{r}
#dm3_track <- UcscTrack(genome ="dm3",track = "ensGene",chromosome ="chr2L",start=16260000, end=16280000,trackType = "GeneRegionTrack",gene ="name",rstarts = "exonStarts",rends = "exonEnds",symbol = "name2", transcript = "name",strand = "strand" )
#axTrack <- GenomeAxisTrack()
#idxTrack <- IdeogramTrack(genome="dm3", chromosome="chr2L")
#How does the gene track look?
#dm3_track
```

We will load bigwigs as GRanges. GRanges is a container of genomic locations and their annotations. In this case, the main annotation would be the number of reads mapped to a genomic location.

```{r}
lt120 <- import.bw("data/Trl_CR_lt_120.bw",as="GRanges")
gt120 <- import.bw("data/Trl_CR_gt_120.bw",as="GRanges")
lt120
```

To visualize a GRange in Gviz, we will make a data track:

```{r}
lt120_trk <- DataTrack(lt120,name='lt120')
gt120_trk <- DataTrack(gt120,name='gt120')
```

Now we have the gene annotations, the chromosome axis, and the actual read density data as tracks that Gviz can read. We can plot the tracks:

```{r}
#plotTracks(c(idxTrack,axTrack,dm3_track,lt120_trk),from=16267330, to=16288550,chromosome = "chr2L",type='h',transcriptAnnotation="gene",shape="arrow")
plotTracks(c(lt120_trk,gt120_trk),from=16267330, to=16288550,chromosome = "chr2L",type='h',transcriptAnnotation="gene",shape="arrow")
```

This profile when normalized, provides the probability of Trl binding to a genomic location with the following caveats:

-   Specificity of the antibody

-   Specificity of the assay (in purifying DNA that is only bound to the epitope)

-   Fidelity of sequencing library preparation and Illumina sequencing (does one fragment from starting sample produce one read?)

So we assume a high probability of background signal - False positives or Type I error. We would like to identify regions with high read densities ("peaks") that we are reasonably certain to represent protein binding to DNA inside cells.

Most peak callers assume a background model for non-specific reads. We will use MACS2 in next class to call peaks. MACS2 uses a Poisson distribution as the background model.

From Wikipedia, the probability mass function (PMF) of Poisson distribution is:

```{r echo=FALSE, fig.cap="Poisson", out.width = '100%'}
knitr::include_graphics("Poisson.png")
```

Translating this PMF:

-   k is the number of reads at a given genomic location

-   Lamda is the expected number of reads at a genomic location

For our dataset, how do we calculate Lambda?

```{r eval=FALSE}
exp_reads = total_reads*average_read_length/effective_genome_size
```

Let us calculate each of these parameters;

```{bash}
total_reads=`awk '{if($4<=120){ct++}} END {print ct}' data/Trl_CR_subset.bed`
ave_read_len=`awk '{if($4<=120){len+=$4;ct++}} END {print len/ct}' data/Trl_CR_subset.bed`
echo "$total_reads $ave_read_len"
```

For effective genome size, we need to figure out the size of chromosome we are using in this class. We will divide this number by 10 as we are binning reads in 10 bp windows.

```{bash}
lower=`sort -k2,2g data/Trl_CR_subset.bed | head -n 1 | awk '{print $2}'`
higher=`sort -k2,2gr data/Trl_CR_subset.bed | head -n 1 | awk '{print $2}'`
size=`echo "$higher $lower" | awk '{print ($1-$2)/10}'`
echo $size
```

Ok, so we have all the parameters to calculate expected reads per bin:

```{r}
total_reads = 10464
ave_size = 69.91
effective_genome_size = 21192
exp_read <- total_reads*ave_size/effective_genome_size
exp_read

```

So based on the read depth and the size of the region we are analyzing, we expect 35 reads in each 10 bp bin.

We can now plot the observed probability of reads per bin and overlay the Poisson distribution with lambda=35:

```{r}
x=seq(0,500)
y=dpois(x,lambda=35)
hist(lt120$score,freq=F,breaks=seq(0.5,500,1),xlim=c(0,200),ylim=c(0,0.15))
lines(x,y,xlim=c(0,200),ylim=c(0,0.15),lwd=3,col="red",type='l')
```

Wow, the observed distribution is highly left shifted compared to expected distribution, which means that the background is very low. Using this theoretical distribution, we can define a cutoff where we are confident that the observed read density would correspond to a "peak".

If we expect 1000 peaks, and we want the probability of observing a peak in the theoretical distribition to be 1e-5, due to multiple testing, our threshold would be 1e-5/1000 = 1e-8.

```{r}
threshold=1e-8 #Really low probability of observing in the theoretical distribution
qpois(p=threshold,lambda = 34,lower.tail = F)
qnorm(p=threshold,mean = 34,sd=sqrt(34),lower.tail = F)
```

Therefore, positions with more than 71 reads can be assumed to belong to "peaks" - where we are pretty sure that the protein bound to DNA inside cells.

Final point before we finish. How does Poisson distribution compare to Normal distribution that we covered in stats bootcamp?

```{r}
x=seq(0,500)
y=dpois(x,lambda=35)
y_norm = dnorm(x,mean=35,sd=sqrt(35))
plot(x,y_norm,xlim=c(0,200),ylim=c(0,0.15),lwd=3,col="blue",type='l')
lines(x,y,xlim=c(0,200),ylim=c(0,0.15),lwd=3,col="red",type='l')
legend("topright",legend = c("Normal", "Poisson"),col = c('blue','red'),pch = 16)
```

They look pretty similar... Or do they?

```{r}
plot(x,log(y_norm),xlim=c(0,200),ylim=c(-200,0.15),lwd=3,col="blue",type='l')
lines(x,log(y),xlim=c(0,200),ylim=c(-200,0.15),lwd=3,col="red",type='l')
legend("topright",legend = c("Normal", "Poisson"),col = c('blue','red'),pch = 16)
```

For our purposes, Poisson is right shifted compared to a Normal distribution with the same mean and variance.

This makes Poisson a more stringent theoretical distribution to call peaks - why?

In the next class, we will use a program that already incorporates all these principles for peak calling.
