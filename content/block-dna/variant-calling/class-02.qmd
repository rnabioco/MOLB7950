---
title: "Genome sequencing 2 - practice"
author: "Your name here"
---

# Variant Calling --- Theory (Review from Friday)

## Sequencing Coverage

From binomial theory, we learned we need a certain level of coverage to generate reliable variant calls, due to the randomness of sampling alleles at a site using sequencing.

We also learned that reads are not distributed randomly in a genome. Coverage is itself a distribution, and we typically discuss it's mean. I.e. 30-fold coverage means *on average* each base is sequenced 30 times.

How do we estimate the numbers of times a base is expected to be sequenced given a certain level of coverage?

This theory comes from [Lander and Waterman](https://pubmed.ncbi.nlm.nih.gov/3294162/), who made two assumptions about sequencing:

1.  Reads will be distributed randomly across the genome.
2.  The ability to detect overlaps (alignments) doesn't vary between reads

They concluded that read coverage is modeled by the Poisson distribution.

The Poisson probability function is:

$$ P(Y = y) = \frac{{ e^{ - C } C ^ y }} {{ y!}} $$

where:

1.  **`y` is the number of times a base is read.** It is the exact number of times a base is sequenced.
2.  **`C` is the mean coverage** (lambda in the traditional Poisson sense). It's the mean number of aligned reads covering a site.

The formula above gives the probability of a base being sequenced a certain number of times.

For example, what is the probability of a base being sequenced *3 times or less* at at mean coverage of 10?

```{r}
sum(dpois(x = 0:3, lambda = 10))
# or ...
ppois(3, lambda = 10)
```

### Excercises

What if we're trying to characterize heterozygous alleles in a human genome at differing levels of coverage?

1.  How many variants are in an average human genome? \[Answer *4285714*\]

```{r}
# size (bp) of the haploid human genome
G <- 3e9
# chance of seeing a common variant in a random person. comes from e.g.
# https://www.nature.com/articles/nature15393
p_var <- 1 / 700

# calculate number of variants
n_var <- G * p_var
n_var
```

2.  How many of these variants have zero coverage (i.e., no reads covering those sites) after sequencing to mean coverage of 5, 15, 30-fold? \[Answer *28876.92, 1.61, 4.01041e-07*\].

```{r}
ppois(0, 5) * n_var
ppois(0, 15) * n_var
ppois(0, 30) * n_var
```

# Variant Calling --- Practice

## Learning objectives

1.  Understand the format and content of VCF files
2.  Learn how to parse and analyze VCF files to summarize and identify candidate variants
3.  Understand the value of variant annotation for variant interpretation.

## The experiment

Yeast alpha and beta tubulin genes encode heterodimeric protein components that assemble into long filaments important for cell division and motility.

1.  The parent strain has two point mutations at the TUB1 and TUB3 loci.
2.  Suppressor mutants of this strain were selected for growth in the presence of a microtubule destabilizing drug.
3.  Suppressor isolates were each backcrossed 2X to the parent strain, confirming that suppression segregates 2:2.
4.  After the backcross, a suppressor F2 isolate was backcrossed to our wild type strain to test whether suppression was linked to the TUB1 or TUB3 mutants; we found suppression was not linked.

Strains 4365-4368 are a tetrad from this F2 x wt cross with genotypes:

1.  4366_S2 (tub sup)
2.  4365_S1 (tub SUP)
3.  4367_S3 (TUB sup)
4.  4368_S4 (TUB SUP)

**Goal: identify and characterize genetic variants that segregate in the expected 2:2 pattern in these strains**

#### The awesome power of yeast genetics

Yeast are not humans (duh). They can be made stably haploid, so the genotype-phenotype link is easier to study.

```{r}
knitr::include_graphics("img/yeast-life-cycle.png")
```

This is valuable because you can directly isolate a recessive mutation in a genetic background. Moreover you can do a cross and identify mutations that segregate with the phenotype among the progeny. The advantage here is that you can identify common variants (relative to the reference genome) that are not associated with phenotype and eliminate them as candidates.

"Backcrossing" refers to the process of crossing an offspring to its wild-type parent. Repeated backcrossing and mutant isolation allows fine mapping of monogenic traits via increased numbers of meiotic crossovers.

#### Human trio sequencing

Identifying variants in a yeast cross is conceptually similar to human trio sequencing, wherein you sequence MOM, DAD, and KID to identify variants in KID that plausibly explain KID's phenotype. The main difference between the yeast and human experiments is that humans are diploid, so you're often looking for either:

1.  Heterzygous alleles of an uncommon variant in MOM and DAD; and a homozygous alternative allele in KID. (recessive case)
2.  Gain-of-function, de novo alleles in KID that are not in MOM and DAD. (dominant case)

You can increase the power of the approach in humans by expanding to people in a pedigree where the phenotype has been annotated.

### Genome sequencing

1.  Purify genomic DNA and shear to \~500 bp fragments
2.  Ligate adaptor oligonucleotides, PCR amplify to incorporate sample-specific barcodes
3.  Sequence this library, collecting \~10 million, 2 x 150 bp reads from the ends of each fragment

### Data analysis

*We're not going to do this because it takes more computational resources than RStudio Cloud can provide. For reference, these two steps take \< 60 minutes (for the yeast genome)*

1.  Align to the reference [Saccharomyces cerevisiae reference genome](https://hgdownload.soe.ucsc.edu/goldenPath/sacCer3/bigZips/) with [bwa](https://github.com/lh3/bwa). \[**`FASTQ > BAM`**\].

    ```         
    bwa mem -x ref.fa reads.fq | samtools sort > alignment.bam
    ```

2.  Call variants in the BAM file with respect to the reference using [freebayes](https://github.com/ekg/freebayes) \[**`BAM > VCF`**\]

    ```         
    freebayes -f ref.fa alignment.bam > combined.vcf
    ```

## VCF inspection

### Variant identification

There two files in `data/`:

1.  `combined.vcf.gz`
2.  `combined.annotated.vcf.gz`

For the first steps, we'll start with the first file, `combined.vcf.gz`.

We'll use command line tools (`zcat`, `grep`, `awk`, `less`) to inspect the file.

Then we'll use the [cyvcf2](https://github.com/brentp/cyvcf2) Python package to do more complex operations with the VCF file.

Let's inspect the VCF file to review its structure.

```{bash}
# What are the first few lines?
# What are the column names (first line after the comment section)
# What is in the INFO field?
# What is in the FORMAT field?
```

How many samples are in the VCF file?

```{bash}
# use bcftools; like samtools but for vcf (bcf)
# https://samtools.github.io/bcftools/howtos/query.html
bcftools query --list-samples data/combined.vcf.gz
```

```{python}
import cyvcf2

vcf = cyvcf2.VCF("data/combined.vcf.gz")
print(vcf.samples)
```

#### Excercises

How many variants are in the VCF file?

First, do this with shell commands:

```{bash}
# zcat data/combined.vcf.gz | grep -c -v "^#"
gzcat data/combined.vcf.gz | grep -c -v "^#"

# using bcftools
bcftools query -f 'pos=%POS\n' data/combined.vcf.gz | wc -l
```

Now do this with python:

```{python}
import cyvcf2
count = 0
for vnt in cyvcf2.VCF("data/combined.vcf.gz"):
    # do something with count. a variant is available each iteration through the for loop
    ...
print(count)  
```

2.  How many sites involve complex REF or ALT alleles (i.e., not SNPs)?

Do this in bash:

```{bash}
# zcat data/combined.vcf.gz | grep -v "^#" | awk 'length($3) != 1 || length($4) != 1' | wc -l
gzcat data/combined.vcf.gz | grep -v "^#" | awk 'length($3) != 1 || length($4) != 1' | wc -l
```

Do this in python:

```{python}
import cyvcf2
count = 0
for vnt in cyvcf2.VCF("data/combined.vcf.gz"):
  # `is_snp` is a boolean attribute attached to each Variant (i.e. vnt.is_snp is True or False)
  ...
print(count)  
```

## Identifying variants associated with phenotypes

In yeast genetics, phenotypic status is represented by capitalization. After selecting for a phenotype and doing genetic mapping, organisms that are wild-type for a trait are noted with upper case letters, while mutant organisms are lower case.

For example, two of the strains below have wild-type tubulin function (TUB) and two others have mutant tubulin function (tub; these are temperature-sensitive alleles of TUB1 and TUB3).

1.  4366_S2 (tub sup)
2.  4365_S1 (tub SUP)
3.  4367_S3 (TUB sup)
4.  4368_S4 (TUB SUP)

**(yes, I know these appear numerically out of order; they're in order with respect to genotype)**

We'll inspect the `gt_types` associated with each variant to ask for variant types that segregate in the expected pattern.

Genotype are encoded with 0, 1, 2, 3 (<https://github.com/brentp/cyvcf2#cyvcf2>):

> `gt_types` is an array of 0,1,2,3 == HOM_REF, HET, UNKNOWN, HOM_ALT\`

So `[0, 0, 0, 0]` means all four samples are HOM_REF (homozygous reference). So `[0, 1, 0, 1]` means samples 1 and 3 are HOM_REF and 2 and 4 are HET (heterozygous).

For variants that explain the *tub* phenotype, we want to filter for `[1, 1, 0, 0]` or `[3, 3, 0, 0]`

For variants that explain the *sup* phenotype, we want to filter for `[1, 0, 1, 0]` or `[3, 3, 0, 0]`

N.B.: The genome of these cells is haploid. But I forgot to adjust the `--ploidy` parameter in freebayes (default is 2, diploid). So some of the sites have enough coverage to be called heterozygous, when really they should only be "homozygous" alternate.

```{python}
import cyvcf2

# print info for the first variant
for vnt in cyvcf2.VCF('data/combined.vcf.gz'):
  chrom = vnt.CHROM; pos = vnt.POS; types = vnt.gt_types
  break
print(chrom, pos, types)  
```

Let's filter for variants that track with the tub phenotype.

```{python}
import cyvcf2

# find mutations that explain tub. it's genotype is encoded like [alt, alt, ref, ref].
# n.b. this is ordered with respect to the sample names in the VCF
gts = [ [1, 1, 0, 0], [3, 3, 0, 0] ]

count = 0
for vnt in cyvcf2.VCF("data/combined.vcf.gz"):
  if vnt.gt_types.tolist() in gts:
    count += 1
    
print(count)
```

That's an excitingly small number! How else might we winnow these down? Hint: let's filter for high confidence calls.

```{python}
import cyvcf2

def high_quality(vnt):
  ''' is a variant high quality? '''
  if vnt.QUAL >= 40 and vnt.INFO.get("DP") >= 40 and vnt.is_snp:
    return True
  return False

# find mutations that explain tub. it's genotype is encoded like [alt, alt, ref, ref].
# n.b. this is ordered with respect to the sample names in the VCF
gts = [ [1, 1, 0, 0], [3, 3, 0, 0] ]

count = 0
for vnt in cyvcf2.VCF("data/combined.vcf.gz"):
  # how would we use `high_quality()` in this check? 
  if vnt.gt_types.tolist() == gts:
    count += 1
    
print(count)
```

Welp. That didn't help much, and we don't have many more ways with this file to winnow down the number further with the existing data

## Variant Annotation

**VARIANT ANNOTATION TO THE RESCUE**.

Remember from my lecture that one key step of variant identification is **variant annotation**.

This involves taking an initial VCF file and annotating each variant and annotating it with data from external sources.

**Question**: What are some things you might want to know about each variant?

The variant annotation step is done using the [snpEff](https://pcingola.github.io/SnpEff/) software, which takes the unannotated VCF file and a set of external annotations and creates a new, annotated VCF.

That new file is in `data/combined.annotated.vcf.gz`.

Let's inspect the annotated VCF. How many variants are in the annotated VCF file? How many are in the unannotated file?

```{bash}

```

Let's find some variants that impact coding regions specifically.

```{bash}

```

Such annotations include whether it's coding or non-coding, what impact it might have on an open reading frame, and even information about the predicted **impact** of specific mutations (LOW, MODERATE, HIGH impacts).

How does the software decide between LOW, MODERATE, and HIGH impacts? This is, in part, pre-calculated in the form of the [BLOSUM matrix](https://en.wikipedia.org/wiki/BLOSUM), which quantifies the log-likelihood of substitutions between resides in a multiple sequence alignments.

**Question:** What drives the low likelihood of substitution between e.g., tryptophan (W) and aspartate (D)? Perhaps looking at amino acid side chain chemistries might help.

```{r}
knitr::include_graphics("img/amino-acids.png")
```

```{python}
import cyvcf2

def high_impact(vnt):
  ''' is a variant high (or moderate) impact ? '''
  anns = vnt.INFO.get("ANN")
  if "HIGH" in anns or "MODERATE" in anns:
    return True
  return False

# find mutations that explain tub. it's genotype is encoded like [alt, alt, ref, ref].
# n.b. this is ordered with respect to the sample names in the VCF
gts = [ [1, 1, 0, 0], [3, 3, 0, 0] ]

keep = []
for vnt in cyvcf2.VCF("data/combined.annotated.vcf.gz"):
  for gt in gts:
    if vnt.gt_types.tolist() == gt and high_quality(vnt) and high_impact(vnt): 
      keep.append(vnt)
    
print(len(keep))
```

**YES!** Now that is a small number of variants. What are they?

```{r eval=FALSE}
# we can access the `keep` object we built in the last chunk like this:
py$keep
```

But that's sort of ugly. Can we clean it up? Let's inspect the contents of the [`ANN` field](https://pcingola.github.io/SnpEff/SnpEff_manual.html).

Try to print:

1.  the chromosome
2.  the position
3.  fields 2, 3, 4, 12, and 13 of the first ANN field (these are joined by commas)

```{python}
# write some code together 
```

## Variant interpretation

Let's try to interpret the impact of this variant.

1.  What's the impact of the variant on the open reading frame?

2.  Where does this mutation lie with respect to annotated protein domains? \[Use yeastgenome.org\]

3.  What's the function of this gene? Has it been linked to tubulin function? \[Use pubmed.com\]

## A thought experiment to compare the utility of Illumina and ONT

Imagine you have a locus structured like this:

```         
----A--B----Alu---<<<<----Alu----C--D------
```

where A, B, C, D are genes, the `<<<<` is a directional promoter, and the Alu elements are representative repetitive elements.

Recombination between the Alu elements could sometimes give you this:

```         
----A--B----Alu--->>>>----Alu----C--D------
```
