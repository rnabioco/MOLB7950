---
title: "R Bootcamp - Day 3"
subtitle: "dplyr"
author: "Jay Hesselberth"
---

```{r include=FALSE}
library(tidyverse)
library(knitr)
library(here)
```


## Class 3 outline 

* Introduce _dplyr_ & today's datasets (Exercise 1)
* Review basic functions of _dplyr_
  * core dplyr verbs: 
  - `arrange` (Exercise 2)
  - `filter` (Exercise 3)
  - `select` (Exercise 4)
  - `mutate`  and the pipe (Exercise 5)
  - `summarise` (Exercise 6)
  * modify scope of verbs using: `group_by` (Exercise 7)
  * and many others! `rename`, `count`, `add_row`, `add_column`, `distinct`,
    `sample_n`, `sample_frac`, `slice`, `pull` (Exercise 8)

## dplyr overview

dplyr: 

* provides a set of tools for efficiently manipulating data sets in R. 
* is extremely fast even with large data sets. 
* follows the tidyverse grammar and philosophy; human-readable and intuitive
* encourages linking of verbs together using pipes `|>` (or the older `%>%`)

## Today's datasets {.smaller}

* We will use a data set that comes with the `dplyr` package to explore its functions.  

* `dplyr::starwars` contains data for characters from Star Wars.

```{r}
#| echo: true
starwars
```

. . .

Explore `starwars` in the console with `head()`, `View()`, and `summary()`.

## dplyr package {.smaller}

`dplyr` is a grammar of data manipulation, providing a consistent set of
verbs that help you solve the most common data manipulation challenges:

  - `arrange()` changes the ordering of the rows.
  - `filter()` picks cases based on their values.
  - `select()` picks variables based on their names.
  - `mutate()` adds new variables that are functions of existing variables
  - `summarise()` reduces multiple values down to a single summary.
 
. . .

- These all combine naturally with `group_by()` which allows you to perform
any operation “by group”. 

- Pipes `|>` allows different functions to be used together to create a
workflow. `x |> f(y)` turns into `f(x, y)`

## arrange - Syntax

- `arrange()` orders rows by values of one or more columns (low to high).
- The `desc()` helper orders high to low. 

```r
arrange(data = ..., <colname>)
```

## arrange - Exercise 2 {.smaller}

```{r}
#| echo: true
#| output-location: fragment
# default is to arrange in ascending order
arrange(starwars, height)
```

---

```{r}
#| echo: true
#| output-location: fragment
# arrange in descending order
arrange(starwars, desc(height))
```

---

```{r}
#| echo: true
#| output-location: fragment
# arrange by multiple columns
arrange(starwars, height, mass)
```

## filter - Syntax

- `filter()` chooses rows/cases where conditions are true.

```r
filter(data = ..., <condition>)
```

## filter - Exercise 3 {.smaller}

```{r}
#| echo: true
#| output-location: fragment
filter(starwars, skin_color == "light")
```

. . .

```{r}
#| echo: true
#| output-location: fragment
filter(starwars, height < 150)
```

---

```{r}
#| echo: true
#| output-location: fragment
filter(
  starwars,
  mass > mean(mass, na.rm = TRUE)
)
```

. . .

Filter out cases where `hair_color` is `NA`

```{r}
#| echo: true
#| output-location: fragment
filter(starwars, is.na(hair_color))
```

---

* Most frequently used comparison operators are:

- `>`, `<`, `>=`, `<=`, `==` (equal), `!=` (not equal)
- `is.na()`, `!is.na()`, and `%in%` (contained in a vector of cases). 

```{r}
#| echo: true
#| output-location: fragment
filter(
  starwars,
  skin_color %in% c("light", "fair", "pale")
)
```

--- 

```{r}
#| echo: true
#| output-location: fragment
# can also store as a named vector and use %in% with the vector
color <- c("light", "fair", "pale")
filter(starwars, skin_color %in% color)
```

---

Conditions can be combined using `&` (and), `|` (or). 

```{r}
#| echo: true
#| output-location: fragment
filter(
  starwars,
  skin_color == "light" | eye_color == "brown"
)
```

. . .

```{r}
#| echo: true
#| output-location: fragment
filter(
  starwars,
  skin_color == "light" & eye_color == "brown"
)
```

## select - Syntax

- `select` extracts one or more columns from a table 

```r
select(data = ..., <colname>)  
```

## select - Exercise 4

```{r}
#| echo: true
#| output-location: fragment
# select *only* the variable `hair_color`
select(starwars, hair_color)
```


```{r}
#| echo: true
#| output-location: fragment
# drop the variable `hair_color`
select(starwars, -hair_color)
```


```{r}
#| echo: true
#| output-location: fragment
select(starwars, hair_color, skin_color, eye_color)
```


```{r}
#| echo: true
#| output-location: fragment
# select variables `hair_color` through `eye_color`
select(starwars, hair_color:eye_color)
```


```{r}
#| echo: true
#| output-location: fragment
# drop variables `hair_color` through `eye_color`
select(starwars, !(hair_color:eye_color))
```


```{r}
#| echo: true
#| output-location: fragment
# `starts_with`, `ends_with`, `contains`
select(starwars, ends_with("color"))
```

## mutate - Syntax

- `mutate()` to compute new columns

```{r, echo = FALSE, out.width= '60%'}
knitr::include_graphics(here("img/mutate.png"))
```

---

```r
mutate(data = ..., <newcolname> =  funs(<oldcolname>))
mutate(data = ..., <colname>, funs(x))
```

. . .

or with the the pipe `|>`

Useful when multiple functions act sequentially on a dataframe.

```r
data |>
  mutate(<colname>, funs(x)) 
```

## mutate (& pipe |>)- Exercise 5

```{r}
#| echo: true
#| output-location: fragment
# create a new column to display height in meters
mutate(starwars, height_m = height / 100)
```

```{r}
#| echo: true
#| output-location: fragment
# using the pipe to feed data into multiple functions sequentially
starwars |>
  mutate(height_m = height / 100) |>
  select(name, height_m, height, everything())
```
---
  
Mutate allows you to refer to columns that you’ve just created

```{r}
#| echo: true
#| output-location: fragment
starwars |>
  mutate(
    height_m = height / 100,
    BMI = mass / (height_m ^ 2)
  ) |>
  select(name, BMI, everything())
```

---

Output needs to be saved into a new dataframe since dplyr does not "change" the original dataframe.

```{r}
#| echo: true
#| output-location: fragment
starwars_bmi <- starwars |>
  mutate(
    height_m = height / 100,
    BMI = mass / (height_m^2)
  ) |>
  select(name, BMI, everything())
```

---

Using `case_when()`clauses with `mutate()`.

Let's create a new variable `tall_short` based on other values.

```{r}
#| echo: true
#| output-location: fragment
#| code-line-numbers: "1-4"
starwars |>
  mutate(
    tall_short = case_when(
      height > 160 ~ "tall",
      .default = "short"
    )
  ) |>
  select(name, tall_short, everything())
```

. . .

**Why use pipes?**

So you don't have to create too many intermediate files! However, intermediate files *can* be useful in the context of troubleshooting a pipeline. 


More information here: https://dplyr.tidyverse.org/articles/rowwise.html

## summarise - Syntax

- `summarise()` reduces multiple values down to a single summary.

```{r, echo = FALSE, out.width= '60%'}
knitr::include_graphics(here("img/summarise.png"))
```

---

```r
summarise(data = ..., <newcolname> =  funs(<oldcolname>))
summarise_at(data = ..., vars(<cols), funs())

```

## `group_by()` & `summarise()` - Exercise 6

`group_by` creates a grouped copy of a table. 

* This changes the unit of analysis from the complete data set to individual groups. 
* dplyr verbs automatically detect grouped tables and calculate “by group”. 

```r
group_by(data = ..., <colname>)
```

## group_by + summarize - Exercise 7

```{r}
#| echo: true
#| output-location: fragment
starwars |> group_by(species)
```

```{r}
#| echo: true
#| output-location: fragment
starwars |> summarise(mean_height = mean(height, na.rm = TRUE))
```

. . .

`summarise()` and `group_by()` on their own are not terribly useful. 

## group_by - Syntax

* `group_by` creates a grouped copy of a table. 
* This changes the unit of analysis from the complete dataset to individual groups. 
* Then, when you use the dplyr verbs on a grouped data frame they’ll be automatically applied “by group”. 

```r
group_by(data = ..., <colname>)
```

## group_by + summarize - Exercise 7

```{r}
#| echo: true
#| output-location: fragment
starwars |>
  group_by(species)
```

---

Group by multiple variables.

```{r}
#| echo: true
#| output-location: fragment
starwars |>
  group_by(species) |> 
  summarise(
    height = mean(height, na.rm = TRUE)
  )
```

---

Calucate multiple summary statistics.

```{r}
#| echo: true
#| output-location: fragment
starwars |>
  group_by(species, gender) |>
  summarise(
    height = mean(height, na.rm = TRUE),
    mass = mean(mass, na.rm = TRUE)
  )
```

## Other dplyr verbs

There are many other dplyr verbs: `rename`, `count`, `add_row`, `add_column`, `distinct`, `sample_n`, `sample_frac`, `slice`, `pull`

Check out the dplyr cheatsheet to learn more! 

## rename - Syntax

- `rename()` renames the variables in a table. Keeps all columns. `select()` can also do this, but with some caveats. 

```r
rename(data = ..., <colname>)
```

## rename - Exercise 9

```{r}
band_instruments2

rename(band_instruments2, name = artist)

select(band_instruments2, name = artist) # select drops the rest of the columns
select(band_instruments2, name = artist, everything()) # this fixes it, but one extra thing to remember
```

## rowwise operations (if time permits)

* dplyr (& tidyverse in general) is very easy to perform vectorized operations column-wise, and not so easy with row-wise operations. 
* the function _rowwise()_ offers a solution to this
* Let's look at an example:

```{r}
# let's input data (same one used in yesterday's problem set)
data <- read_csv(here("data/data_transcript_exp_subset.csv"))

# calculate mean for each time point using mutate in a rowwise fashion!
data_mean <- data |>
  rowwise() |>
  mutate(
    mean_0h = mean(c(rna_0h_rep1, rna_0h_rep2, rna_0h_rep3)),
    mean_14h = mean(c(rna_14h_rep1, rna_14h_rep2, rna_14h_rep3))
  )
```
