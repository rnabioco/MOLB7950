{
  "hash": "9a2e8aefee29884d75e8818e7c44299b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Single-cell RNA-seq Problem Set II\"\nauthor: \"Your name here\"\n---\n\n\n\nGrade (out of 20):\n\nFor this problem set we will be reanalyzing some public single cell RNA-seq data ([publication](https://doi.org/10.1038/s41591-018-0233-1)). The dataset contains PBMCs from a patient with Acute Myeloid Leukemia (AML). The dataset is a little different than the one we looked at in Mondays problem set, as we will also include a day 4 sample. The data we will be analyzing consists of three samples, PBMCs taken 4 days (day4), 2 days (day2), and prior to (day 0) treatment with a chemotherapeutic (Venetoclax and Azacitidine).\n\nThe three single cell RNA-seq datasets have already been preprocessed and QC'd. There is an `.rds` file (`data/aml/d0_d2_d4_filtered.rds`) provided that contains the combined samples in a single seurat object. We will use this seurat object for this homework. \n\nQ1 4 points) Read the `.rds` file containing the Seurat object into R using the `readRDS()` function. Use tab-completion to ensure that you are specifying the correct path to the object.    \n\n\n\n::: {.cell}\n\n:::\n\n\n\nQ2 4 points) Process the dataset to generate a UMAP projection. Plot your UMAP with each cell colored by the day of sample (e.g day 0, day 2 or day 4). Examine the meta.data to find the column that contains the day of sample information. Consult the simplified work-flow shown at the beginning of class on Monday for a default approach to this question (you don't need to worry about picking parameters here). \n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#head(so@meta.data)\n```\n:::\n\n\n  \nQ3 4 points) Make a UMAP plot showing the clusters that you have generated. To make this plot more informative use the `split.by` argument set to the column with the day information. This will split the UMAP into three plots ( `day0`, `day2` and `day4`). Remember that to plot categorical data you need to use `UMAPPlot()` and for numeric data use `FeaturePlot()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# code here\n```\n:::\n\n\n\nQ4 2 points) Use the `clustifyr` package to annotate cell types using a reference dataset from `clustifyrdatahub`. Use the `ref_hema_microarray()` reference shown in class. Plot a heatmap (using `pheatmap`) of the correlation coefficients between your clusters and the cell types in the reference data. Note that you need to set `obj_out` = FALSE to return the correlation coefficients as a data.frame. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(clustifyr)\nlibrary(clustifyrdatahub)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ExperimentHub\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: BiocGenerics\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'BiocGenerics'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:SeuratObject':\n\n    intersect\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:lubridate':\n\n    intersect, setdiff, union\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:dplyr':\n\n    combine, intersect, setdiff, union\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,\n    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,\n    Position, rank, rbind, Reduce, rownames, sapply, setdiff, table,\n    tapply, union, unique, unsplit, which.max, which.min\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: AnnotationHub\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: BiocFileCache\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: dbplyr\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dbplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:dplyr':\n\n    ident, sql\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(pheatmap)\n# code here\n```\n:::\n\n\n\nQ5 2 points) Run clustifyr but this time assign the output of `clustify` to return a Seurat object. The cell classifications will be listed in the `type` column. Make a UMAP plot colored by the assigned cell types.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# code here\n```\n:::\n\n\n\nQ6 4 points) For each day (e.g. day0 day2 and day4) calculate the % of cells present in each cluster. Using ggplot, plot with the cell type on the x axis and the % on the y-axis. Then use a fill aesthetic to color by the day of each sample.  If your x-axis labels are all squished together consider rotating the label using the following pseudocode:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#ggplot... +\n#  theme(axis.text.x = element_text(angle = 90))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Hint - calculate % of cells using tidyverse, remember so@meta.data gives a data frame\n# % of cells will be # of cells in the cluster / total cells for each day. Summarize can\n# help you get the total number of cells\n# ex\n#so@meta.data %>%\n#  dplyr::group_by(orig.ident, type) # Finish this to count the number of cells\n# code here\n```\n:::\n\n\n\nHow does the relative abundance change of each cell type change?\n\n    Short answer here...\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}