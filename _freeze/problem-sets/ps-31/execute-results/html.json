{
  "hash": "52a3e690db32f12dbbcb6e9527876998",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Single-cell RNA-seq Problem Set\"\nauthor: \"Yor name here\"\n---\n\n\n\nGrade (out of 20):\n\n\nFor this problem set we will be reanalyzing some public single cell RNA-seq data ([publication](https://doi.org/10.1038/s41591-018-0233-1)). The dataset contains PBMCs from a patient with Acute Myeloid Leukemia (AML). The data we will be analyzing consists of two samples, one taken 2 days (day2) after treatment with a chemotherapeutic (Venetoclax and Azacitidine) or one taken prior to treatment (day0). \n\nThe datasets have been processed with `alevin`, and the output is here `aml/alevin/`. \n\nA common strategy to analyze multiple samples is to combine them into a single matrix prior to downstream processing. This simplifies the data analysis because the clustering values and PCA/UMAP coordinates are comparable between the samples. \n\nEach question is worth 2 points\n\n1: Load the matrices for each sample into R separately using `tximport`. How many cells are in each sample?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#tximport(...) \n#tximport(...)\n```\n:::\n\n\n\n2: Rename the cell barcodes for each sample, appending a sample identifier to the cell barcode. This ensures that the cell barcodes are unique for each sample. Print the first 5 renamed cell barcodes from each sample.\n\nA common approach is to add a sample identifier as a prefix to the cell barcode, e.g.:\n\n`sample1_ATCGTAGCTAGTG`\n`sample2_GTCGATGCTGATG`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# assume that d0_mat is the day 0 count matrix\n# assume that d2_mat is the day 2 count matrix\n\n#colnames(d0_mat) <- paste0(\"sample_identifier_\", colnames(d0_mat))\n#...              <- paste0(\"another_identifier_\", colnames(d2_mat))\n```\n:::\n\n\n\n\n3: Combine the two count matrices into 1. See ?cbind for help.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#...\n```\n:::\n\n\n\n4: Create a SingleCellExperiment object from this new combined matrix. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#sce <- SingleCellExperiment(list(counts = ...)) # Fill in the ...\n```\n:::\n\n\n\n\n5: Assign a new column into the colData that indicates the sample treatment day (e.g. day0 or day2). *Hint: functions from stringr may be helpful here*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#sce$day <- ...\n```\n:::\n\n\n\n\n6: Next we will want to convert the ensembl gene ids into something more interpretable, such as gene symblols. Obtain gene symbols from ensembDb and store these in the rowData().  Make the gene symbols unique and assign them to the rownames of the SingleCellExperiment. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#library(AnnotationHub)\n#ens_db <- ah[[\"AH113665\"]]\n#... <- mapIds(...)\n\n#rowData(sce) <- ...\n```\n:::\n\n\n\n7: Next calculate the % of UMIs that are derived from mitochondrial genes and store it in the colData. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remember the pattern for human mitochondrial genes is \"^MT-\"\n...\n\n#sce <- addPerCellQCMetrics(...)\n```\n:::\n\n\n\n8: Plot this % of UMIs that are derived from mitochondrial genes against the # of UMIs per cell. Color each point by the sample treatment day.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plotColData(sce, ..., ..., ...)\n```\n:::\n\n\n\n9: Plot the # of UMIs and # of genes detected as violin plots. Plot each sample as separate groups on the x-axis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plotColData(sce, .., ...)\n\n#plotColData(sce, ..., ...)\n```\n:::\n\n\n\n\n\n10: Based on these plots, select cutoffs to exclude low-quality cells and filter your SingleCellExperiment object. Provide an explanation of your reasons for selecting the cutoffs chosen and report the # of cells remaining in each sample after filtering. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#pass_qc <- sce$... < X & sce$... > Y ...\n#sce[, ...]\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}