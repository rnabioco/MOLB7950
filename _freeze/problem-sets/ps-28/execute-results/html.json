{
  "hash": "ce53b9a370a420e9070ab4c151ea7ced",
  "result": {
    "markdown": "---\ntitle: \"RNA Block - Problem Set 28\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(BSgenome.Hsapiens.UCSC.hg19)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: BSgenome\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: BiocGenerics\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,\n    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,\n    Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort,\n    table, tapply, union, unique, unsplit, which.max, which.min\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: S4Vectors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: stats4\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'S4Vectors'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:utils':\n\n    findMatches\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    expand.grid, I, unname\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: IRanges\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: GenomeInfoDb\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: GenomicRanges\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Biostrings\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: XVector\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'Biostrings'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:base':\n\n    strsplit\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: rtracklayer\n```\n:::\n\n```{.r .cell-code}\nlibrary(TxDb.Hsapiens.UCSC.hg19.knownGene)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: GenomicFeatures\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: AnnotationDbi\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Biobase\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWelcome to Bioconductor\n\n    Vignettes contain introductory material; view with\n    'browseVignettes()'. To cite Bioconductor, see\n    'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n```\n:::\n\n```{.r .cell-code}\nlibrary(annotatr)\nlibrary(org.Hs.eg.db)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggrepel)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: ggplot2\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3          ✔ readr     2.1.4     \n✔ forcats   1.0.0          ✔ stringr   1.5.0     \n✔ lubridate 1.9.3          ✔ tibble    3.2.1     \n✔ purrr     1.0.2.9000     ✔ tidyr     1.3.0     \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ lubridate::%within%() masks IRanges::%within%()\n✖ dplyr::collapse()     masks Biostrings::collapse(), IRanges::collapse()\n✖ dplyr::combine()      masks Biobase::combine(), BiocGenerics::combine()\n✖ purrr::compact()      masks XVector::compact()\n✖ dplyr::desc()         masks IRanges::desc()\n✖ tidyr::expand()       masks S4Vectors::expand()\n✖ dplyr::filter()       masks stats::filter()\n✖ dplyr::first()        masks S4Vectors::first()\n✖ dplyr::lag()          masks stats::lag()\n✖ ggplot2::Position()   masks BiocGenerics::Position(), base::Position()\n✖ purrr::reduce()       masks GenomicRanges::reduce(), IRanges::reduce()\n✖ dplyr::rename()       masks S4Vectors::rename()\n✖ lubridate::second()   masks S4Vectors::second()\n✖ lubridate::second<-() masks S4Vectors::second<-()\n✖ dplyr::select()       masks AnnotationDbi::select()\n✖ dplyr::slice()        masks XVector::slice(), IRanges::slice()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(cowplot)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'cowplot'\n\nThe following object is masked from 'package:lubridate':\n\n    stamp\n```\n:::\n\n```{.r .cell-code}\nlibrary(scales) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'scales'\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n```\n:::\n\n```{.r .cell-code}\nlibrary(gt)\nlibrary(here)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nhere() starts at /Users/nmukherjee/Dropbox/My Mac (Neelanjan’s MacBook Pro)/Documents/GitHub/molb-7950\n```\n:::\n:::\n\n\n\n## Problem Set\n\nTotal points: 20. Q1 - 10 pts, Q2 - 10 points each.\n\nExercises: 1. Identify the transcript regions most enriched for binding by the RBP ZFP36. 2. Within that preferentially bound region, identify which **5mers** ZFP36 most likes to bind to.\n\n\nRemember all the data is available here: [rag-tag ENCODE](https://github.com/BIMSBbioinfo/RCAS_meta-analysis)  \n\nWe are looking for an ZFP36 PAR-CLIP corresponding to this SRA (short-read archive) ID: **SRR1046759**  \n\t\n\n## 1. Determine the annotation region most enriched for ZFP36  binding sites.\n\nTo do so you will need to annotate the **ZFP36 binding sites** and a **randomized set of binding sites** (based on ZFP36 binding sites) to determine the which binding region is preferred by ZFP36 binding.\n\n## 1a. Build annotation database  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# What annotation categories are available?\npossible_annotations <- builtin_annotations()\n\n# Keep only those containing \"hg19\"\nhg19_annots <- grep(\"hg19_genes\", possible_annotations, value = T)\n\n\n# let's keep 5' utr, cds, intron, 3' utr and intergenic\nmy_hg19_annots <- hg19_annots[c(3,4,7,10,11)]\n\n\n# build the annotation database\nannotations <- build_annotations(genome = 'hg19', annotations = my_hg19_annots)\n```\n:::\n\n\n\n## 1b. Annotate the ZFP36 binding sites\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We are importing a bed file directly from github for zfp36 binding sites\nzfp36_regions <- read_regions(con = \"https://raw.githubusercontent.com/BIMSBbioinfo/RCAS_meta-analysis/master/rbp-binding-sites/SRR1046759.clusters.bed\",\n                     genome = 'hg19', format = 'bed')\n\n\n# annotate zfp36 binding sites and convert to df\nzfp36_annot <-\n  annotate_regions(??) %>%\n  data.frame()\n\n# We will keep only columns we need and collapse the redundant info\nmyInfo <- c(\"seqnames\",\"start\",\"end\",\"width\",\"strand\",\"annot.symbol\",\"annot.type\")\n\nzfp36_annot <- zfp36_annot[,??] %>%\n  unique() \n\n# Just getting rid of the \"hg19_genes_\" string to simplify `annot.type`\n\nzfp36_annot$annot.type <- gsub(\"hg19_genes_\",\"\",zfp36_annot$annot.type)\n\ntable(zfp36_annot$annot.type)\n```\n:::\n\n\n## 1c. Annotate the randomized binding sites\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_regions <- randomize_regions(??)\n\nrandom_annot <- annotate_regions(??) %>%\n  data.frame()\n\nrandom_annot <- random_annot[,??] %>%\n  unique() \n\nrandom_annot$annot.type <- gsub(\"hg19_genes_\",\"\",random_annot$annot.type)\n```\n:::\n\n\n## 1d. Determine which regions exhibit more  than expected ZFP36 binding sites.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsite_dist <- bind_cols(\n  region=??(??(??$annot.type)),\n  observed=??(??$annot.type),\n  expected=??(??$annot.type)\n          )\n\nsite_dist$enrichment <- site_dist$observed/site_dist$expected\n\n\nsite_dist_long <- pivot_longer(site_dist,cols = c(??,??,??))\n\ncolnames(site_dist_long) <- c(\"region\",\"type\",\"value\")\n\nggplot(?? %>% filter(type==\"??\"), aes(y = ??, x = ??)) +\n  geom_bar(stat=\"identity\") +\n  ylab(\"Observed vs Expected\") +\n  theme_cowplot()\n```\n:::\n\n\n![](/img/block-rna/zfp36_enrich.png)\n\n## 2. Determine the preferred seqeunces bound by **ZFP36**. \n\nYou have determined which region ZFP36 binding sites are preferred to reside -  the **3' UTR** :).  \nFocusing on 3'  UTR binding  sites, determine which sequences ZFP36 binds to compared to background sequences for that region **USING 5mers**.\n\nRemember the workflow for determine k-mer composition (**USING 5mers**) for any set of intervals (binding sites or annotation categories).\n\n1. Create a `Granges` object for a given annotation category.  \n2. Remove duplicated intervals (from diff transcript  ids) with `reduce`.   \n3. Retrieve seqeunces using  `getSeqs`\n4. Create a dataframe containing the count and frequency of each 5mer.\n\n----\n\n# 2a. Calculate 5mers in ZFP36 binding sites in 3' UTRs.  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a Grange for zfp36 3' UTR sites \n\nzfp36_3utr <- makeGRangesFromDataFrame(df = ?? %>% filter(annot.type==\"??\"), ignore.strand = F, seqnames.field = \"seqnames\", start.field = \"start\", end.field = \"end\", strand.field = \"strand\", keep.extra.columns = T)\n\n\n# get sequencees for those coordinates\nzfp36_3utr_seqs <- getSeq(??, ??)\n\n# count  all 5mer instances per sequence, add all instances, and turn into a dataframe with column name counts\n\nzfp36_3utr_5mer <- ??(x = ??,\n                      width = ??,\n                      as.prob = F,\n                      simplify.as=\"matrix\") %>%\n  colSums(.) %>%\n  as.data.frame()\n\ncolnames(zfp36_3utr_5mer) <- \"zfp36_utr_count\"\n\nzfp36_3utr_5mer$zfp36_utr_freq <- zfp36_3utr_5mer$zfp36_utr_count/sum(zfp36_3utr_5mer$zfp36_utr_count)\n```\n:::\n\n\n\n# 2b. Calculate 5mers in 3' UTRs.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a Grange for 3' UTRs \nthreeUTR <- GenomicRanges::reduce(annotations[annotations$type %in% my_hg19_annots[??]])\n\n# get  sequencees for those coordinates\nthreeUTR_seqs <- getSeq(??, ??)\n\n# count  all 5mer instances per sequence, add all instances, and turn into a dataframe with column name counts\nutr3_5mer <- oligonucleotideFrequency(\n  x = ??,\n  width = ??,\n  as.prob = F,\n  simplify.as=\"matrix\") %>%\n  colSums(.) %>%\n  as.data.frame()\n\ncolnames(utr3_5mer) <- \"utr_count\"\n\nutr3_5mer$utr_freq <- utr3_5mer$utr_count/sum(utr3_5mer$utr_count)\n```\n:::\n\n\n# 2c. Compare 5mer frequencies in ZFP36 binding sites vs background.\n\nLabel 5mers that are 8x, **remember log2(8) = 3**, enriched above  background.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check if rownames are identical and stop if they are  not\nstopifnot(identical(rownames(zfp36_3utr_5mer),rownames(utr3_5mer)))\n\nutr3_df <- bind_cols(??,??)\n\nutr3_df$zfp36_enrich <- utr3_df$zfp36_utr_freq/utr3_df$utr_freq\n\n\n# scatter plot\nggplot(data = ??,\n       aes(y = ??, x = ??)) +\n  geom_point(color = ifelse(utr3_df$?? > 8, \"red\", \"black\")) +\n  ylab(\"ZFP36 3'UTR\") + xlab(\"3'UTR\") +\n  geom_abline(intercept = 0, slope = 1) +\n  geom_text_repel(aes(label=ifelse(?? > 8,\n                                   rownames(utr3_df),\n                             \"\"))) +\n  theme_cowplot()  \n\n# print top 10 with gt\n?? %>%\n  rownames_to_column(var = \"5mer\") %>%\n  arrange(-??) %>%\n  top_n(n = 10) %>%\n  gt()\n```\n:::\n\n\n![](/img/block-rna/zfp36_scatter.png)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}