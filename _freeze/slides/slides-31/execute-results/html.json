{
  "hash": "21e8da7e78c08a371bdbc603fe85c56e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Single cell RNA-Seq\"\nsubtitle: \"Introduction and Quality Control\"\nauthor: \"Kent Riemondy and Kristen Wells\"\n---\n\n\n\n\n\n\n## Contact Info \n\nGreetings experimentalist humans üëã\n\n<i class=\"fa fa-envelope\"></i> &nbsp; [kristen.wells-wrasman@cuanschutz.edu](mailto:kristen.wells-wrasman@cuanschutz.edu) <br>\n\nRBI Informatics Fellows [Office hours](https://medschool.cuanschutz.edu/rbi/training-and-education/rbi-office-hours)\n\n<i class=\"fa fa-envelope\"></i> &nbsp; [rbi.fellows@cuanschutz.edu](mailto:rbi.fellows@cuanschutz.edu) \n<br>\n\n## Learning key\n* We will switch between lecture and your exercise `qmd`. \n* To denote a slide that corresponds to your exercise, I will include ‚å®Ô∏è in the slide title\n\n## Learning Objectives\n\n:::: {.columns}\n\n::: {.column .nonincremental width=\"49%\"}\n### Lecture 1\n- Identify key quality control issues with single cell RNA-seq data and perform filtering to exclude poor quality cells \n- Interact with single cell data using Bioconductor tools\n\n::: \n\n::: {.column width=\"2%\"}\n\n:::\n \n::: {.column .nonincremental width=\"49%\"}\n### Lecture 2 \n- Perform analysis to identify cell types in single cell data by using unsupervised clustering methods and comparing to public datasets\n- Describe the importance and reasoning for conducting each step of the analysis\n\n::: \n\n::::\n\n## Single cell or bulk? {.smaller}\n\n:::: {.columns .incremental}\n\n::: {.column .incremental width=\"49%\"}\n### Single cell\n* High level overview of general transcriptomic landscape of genes that are expressed highly at the single cell level\n  * Sequencing depth is low per cell so we only have confident detection of highly expressed genes\n  * Differential expression is less well developed to compare different conditions\n* Most techniques only capture the 5' or 3' end\n* Good for identifying subpopulation of cells that change between conditions\n  * Doesn't require prior knowledge of surface proteins to sort out a population\n  * Doesn't average across all cells in the experiment\n\n:::\n\n::: {.column width=\"2%\"}\n\n:::\n\n::: {.column .incremental width=\"49%\"}\n### Bulk\n* Global overview of transcriptomic landscape of an entire sample using high to low expressed genes.\n  * Sequencing depth is much deeper so there is higher confidence to detect mid to low range expression\n  * Good for novel transcript identification and assessing how global transcriptome changes between conditions\n* Captures full RNA molecule so can be used for RNA-splicing analysis\n* Doesn't work for subpopulation analysis\n  * All cells are averaged so determining what is happening to one cell type is challenging\n  * Are your results because of a transcriptomic change or a change in cell type frequencies?\n\n:::\n\n::::\n\n## Single cell sequencing {.smaller}\n\n:::: {.columns}\n\n::: {.column}\n\n![](../img/block-rna/10x_bead_example.jpg)\n\n![](../img/block-rna/cb-umi-scheme.jpg)\n::: \n\n::: {.column}\n\n![](../img/block-rna/drop-generation.png)\n\n::: \n\n::::\n\n## Where is the barcode and UMI?\n\n* Below is the design for the 3' 10x genomics assay\n![](../img/block-rna/cb-umi-scheme.jpg)\n\n* Other assays may have different locations of there cell barcode and UMI.\n* These may also be different lengths.\n* Or even on read 2 (ex Parse bioscience).\n* Be sure to check what kit was used to prep your data and always perform sanity checks throughout the analysis!\n\n## Library prep\n\n![](../img/block-rna/10x-library-scheme.jpg)\n\n\n\n## Other single cell methods  \n  \n   droplet-based scRNA-seq: e.g. 10x Genomics or Drop-Seq  \n\nSmart-seq based scRNA-seq: (bulk-RNA-seq on single cells in individual wells/tubes)  \n  \n[CITE-Seq](http://cite-seq.com/): gene expression + cell surface protein abundance  \n  \n[VDJ-Seq](https://www.10xgenomics.com/products/single-cell-immune-profiling): Gene expression + targeted sequencing of T-Cell and B-Cell receptors   \n  \nMany others: ATAC, spatial transcriptomics, DNA sequencing, etc. (see [Integrative Single cell analysis](https://www.nature.com/articles/s41576-019-0093-7))  \n\n## Overview of analysis steps\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"grViz html-widget html-fill-item\" id=\"htmlwidget-d7b8585542a339b71351\" style=\"width:60%;height:50%;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-d7b8585542a339b71351\">{\"x\":{\"diagram\":\"\\ndigraph workflow {\\n  graph [layout = dot,\\n         rankdir = TB]\\n\\n  node [shape = cicle,\\n        style = filled,\\n        fontcolor = black,\\n        fontname = \\\"Helvetica\\\"]\\n\\n  # green\\n  node [fillcolor = \\\"#009E73\\\"]\\n  cr [label = \\\"Process FASTQ to UMI count matrix\\n(Cellranger, Alevin, or STARsolo)\\\"]\\n\\n  # blue\\n  node [fillcolor = \\\"#56B4E9\\\"]\\n  cell_qc [label = \\\"QC cells\\n (% mitochondrial UMIs,\\n# of UMIs/Genes,\\nremove empty droplets)\\\"]\\n  norm [label = \\\"Normalize UMI counts\\n(Normalize by deconvolution)\\\"]\\n\\n  # yellow\\n  node [fillcolor = \\\"#F0E442\\\"]\\n  feature [label = \\\"Identify variable genes\\n(a.k.a Feature selection)\\\"]\\n  dim_red [label = \\\"Dimensionality reduction (PCA)\\\"]\\n  cluster [label = \\\"Clustering\\n (using Shared Nearest Neighbors)\\\"]\\n  viz [label = \\\"Make 2D-Visualization\\n(PCA, UMAP, tSNE\\nForce-directed graph)\\\"]\\n  traj [label = \\\"Trajectory Inference\\n(Slingshot,\\nPAGA, scVelo)\\\"]\\n\\n  # blue\\n  node [fillcolor = \\\"#56B4E9\\\"]\\n\\n  markers [label = \\\"Discover cell type markers\\\"]\\n  annot [label = \\\"Annotate cell types\\\"]\\n\\n  # orange\\n  node [fillcolor = \\\"#E69F00\\\"]\\n  downstream  [label = \\\"Downstream analysis\\n(Differential expression,\\nShifts in cell type composition,\\n Find new cell-types/states)\\\"]\\n\\n  edge [color = black\\n        fontname = \\\"Helvetica\\\"]\\n\\n  cr -> cell_qc [label = \\\"Load into \\nSingleCellExperiment\\\"]\\n  cell_qc -> norm\\n  norm -> feature\\n  norm -> markers\\n  feature -> dim_red\\n  dim_red -> cluster\\n  dim_red -> traj\\n  dim_red -> viz\\n  cluster -> markers\\n  markers -> annot\\n\\n  edge [color = \\\"grey\\\"\\n        style = \\\"dashed\\\"]\\n  annot -> cell_qc [label = \\\"Repeat\\n as needed\\\"]\\n  annot -> feature\\n  annot -> dim_red\\n  annot -> cluster\\n  annot -> downstream\\n}\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n\n\n## From raw reads to a UMI count matrix\n\n:::: {.columns}\n\n::: {.column}\n\n![](../img/block-rna/count-matrix.png)\n\n::: \n\n\n::: {.column .nonincremental}\n\n- [`cellranger`](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger) from 10x Genomics (STAR)\n- [`alevin`](https://salmon.readthedocs.io/en/latest/alevin.html) (Salmon)\n- [`STAR-solo`](https://github.com/alexdobin/STAR/blob/master/docs/STARsolo.md) (From the STAR developers)\n \n:::\n\n\n::::\n\n## Alevin\n\n```bash\n$ salmon -h\nsalmon v1.3.0\n\nUsage:  salmon -h|--help or\n        salmon -v|--version or\n        salmon -c|--cite or\n        salmon [--no-version-check] <COMMAND> [-h | options]\n\nCommands:\n     index      : create a salmon index\n     quant      : quantify a sample\n     alevin     : single cell analysis # <------\n     swim       : perform super-secret operation\n     quantmerge : merge multiple quantifications into a single file  \n```\n\n\n\n## Alevin\n\n```bash\n$ salmon index ...\n$ salmon alevin \n   -l ISR                    # library type\n   -1 read1.fastq.gz         # reads \n   -2 read2.fastq.gz         # reads\n   --chromiumv3              # chemistry\n   -i /path/to/salmon/index  # index path\n   -o /path/to/output        # output\n   --tgMap transcript_to_gene.tsv \n```\n\n## Alevin output files\n\n```bash\n$ls alevin/\nalevin.log          # run info\nfeatureDump.txt     # info on each cell barcode\nquants_mat.gz       # binary file with UMI counts \nquants_mat_cols.txt # genes in count matrix\nquants_mat_rows.txt # cell barcodes in count matrix\nquants_tier_mat.gz  # info about mapping for each gene\nwhitelist.txt       # valid barcodes discovered by alevin\n```\n\n## AlevinQC\n\nCan generate interactive QC reports using [alevinQC](https://csoneson.github.io/alevinQC/)\n\n[PBMC QC report](../data/block-rna/scrna/qc/pbmc/alevinReport.html)\n\n\n\n## QC: cell or empty droplet? {.smaller}\n\n:::: {.columns}\n\n::: {.column .nonincremental width=\"50%\"} \n\n- In a typical droplet scRNA-seq experiment 100k - 1M cell barcodes are \ndetected, but only 1-10k cells are loaded\n\n- Most of these droplets are \"empty\" and contain very few reads. \n\n- What is the source of these reads in the \"empty\" droplets?\n\n- How do we determine if the data from a particular cell barcode is derived from a single cell?\n\n::: \n\n::: {.column width=\"50%\"} \n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/cb-umi-plot-1.png){width=864}\n:::\n:::\n\n\n\n:::\n\n::::\n\n## QC: cell or empty droplet?  {.smaller}\n\n:::: {.columns}\n\n::: {.column width=\"50%\"} \n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/unnamed-chunk-2-1.png){width=864}\n:::\n:::\n\n\n\n::: \n\n::: {.column width=\"50%\"} \n\n- Fit a curve to the observed data and identify point where first derivative is minimized.\n\n- Any barcodes less than the \"knee\", test sequences for off-by-one errors against the barcodes above the knee.\n\n- Take top half of cells above the knee and train a classifier using multiple criteria (% mapping, % mitochondrial and rRNA reads, duplicate rate, ...)\n\n- Classify ambiguous cells in lower half into likely cells or not.\n:::\n\n::::\n\n\n\n## QC: Cell or empty droplet? \n\n:::: {.columns}\n\n::: {.column} \n\n#### Good data\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/plot-label-1.png){width=864}\n:::\n:::\n\n\n\n::: \n\n::: {.column} \n\n#### Bad data\n\n![](../img/block-rna/bad_data.png)\n\n:::\n\n::::\n\n## Cell calling sanity check {.incremental}\n* It's always a good think to sanity check your data\n* After calling cells, how can we perform a sanity check?\n* I once reanalyzed data from a *published* paper and found that they had treated two separate sequencing runs as two separate captures. If this happens to you, what is a quick and easy way to make sure you treated your data correctly at the cell calling step?\n\n## Doublets and Multiplets {.smaller}\n\n:::: {.columns}\n\n::: {.column width=\"50%\"} \n\n\n![](../img/block-rna/10x-barnyard.png)\n\n:::\n\n::: {.column width=\"50%\"} \n\n- Doublets are not clearly identifiable using simple QC metrics, so cannot be reliably removed with filtering with # of UMIs or genes detected. \n\n- `scran::doublet_cluster` : Compare each cluster to an in silico mix of two other clusters. Get per cluster score of likelihood of being a doublet.\n\n- `scran::doublet_cell` : Compare each cell to a mix of two other randomly selected cells. Get per cell score of likelihood of being a doublet.\n\n- Doublets can also arise due to sample prep, e.g. incomplete generations of a single cell suspension. These doublets are difficult to exclude from the data\n\n:::\n\n::::  \n\n## Turning to our exercise ‚å®Ô∏è\nBefore jumping into the analysis, let's step back and start running through the exercise for today\n\nStart by loading in the packages\n\n```r\nlibrary(here)\nlibrary(scran)\nlibrary(scater)\nlibrary(SingleCellExperiment)\nlibrary(DropletUtils)\nlibrary(tximport)\nlibrary(Matrix)\nlibrary(AnnotationHub)\nlibrary(eds)\n```\n\n## Raw data: the UMI count matrix ‚å®Ô∏è\n\n:::: {.columns}\n\n::: {.column .nonincremental width=\"50%\"}\n\n- scRNA-seq libraries produce reads from 100,000 - 1,000,000 cell barcodes\n\n- A matrix of 20,000 genes x 1,000,000 barcodes is 20 billion values (!). \n\n- \\>95% are zeros due to empty droplets and the low efficiency of the library prep (< 10-20% of RNA captured).\n\n:::\n\n::: {.column}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvals <- c(\n  0, 0, 0, 2, 0,\n  0, 1, 0, 0, 0,\n  0, 0, 0, 0, 0,\n  0, 0, 0, 0, 1,\n  0, 0, 0, 0, 0\n)\nm <- matrix(vals, ncol = 5)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    0    0    0\n[4,]    2    0    0    0    0\n[5,]    0    0    0    1    0\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1            V2            V3          V4            V5   \n Min.   :0.0   Min.   :0.0   Min.   :0   Min.   :0.0   Min.   :0  \n 1st Qu.:0.0   1st Qu.:0.0   1st Qu.:0   1st Qu.:0.0   1st Qu.:0  \n Median :0.0   Median :0.0   Median :0   Median :0.0   Median :0  \n Mean   :0.4   Mean   :0.2   Mean   :0   Mean   :0.2   Mean   :0  \n 3rd Qu.:0.0   3rd Qu.:0.0   3rd Qu.:0   3rd Qu.:0.0   3rd Qu.:0  \n Max.   :2.0   Max.   :1.0   Max.   :0   Max.   :1.0   Max.   :0  \n```\n\n\n:::\n:::\n\n\n\n::: \n\n::::\n\n## Sparse matricies ‚å®Ô∏è {.nonincremental .smaller}\n\n* Use the `as` function to convert to a sparse matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsm <- as(m, \"sparseMatrix\")\n# alternatively\n# Matrix(vals, nrow = 5)\nsm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5 x 5 sparse Matrix of class \"dtCMatrix\"\n              \n[1,] . . . . .\n[2,] . 1 . . .\n[3,] . . . . .\n[4,] 2 . . . .\n[5,] . . . 1 .\n```\n\n\n:::\n:::\n\n\n\n* This only stores non-zero values\n* Internally, values are stored as a row column value triplet\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(sm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5 x 5 sparse Matrix of class \"dtCMatrix\", with 3 entries\n  i j x\n1 4 1 2\n2 2 2 1\n3 5 4 1\n```\n\n\n:::\n:::\n\n\n\n## Sparse matricies ‚å®Ô∏è\n* Functions at manipulate matricies (`rowMeans`, `colSums`, `apply`, `[`) can be used on sparseMatricies as long as the `Matrix` package is loaded.\n\n* How can we extract the first 2 rows and first 3 columns of the sparse matrix `sm` that we generated above?\n\n## Sparse matricies ‚å®Ô∏è {.nonincremental}\n* Functions at manipulate matricies (`rowMeans`, `colSums`, `apply`, `[`) can be used on sparseMatricies as long as the `Matrix` package is loaded.\n\n* How can we extract the first 2 rows and first 3 columns of the sparse matrix `sm` that we generated above?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# print subset of sm\nsm[1:2, 1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2 x 3 sparse Matrix of class \"dgCMatrix\"\n          \n[1,] . . .\n[2,] . 1 .\n```\n\n\n:::\n:::\n\n\n\n## Sparse matricies ‚å®Ô∏è\nHow can we calculate the sum of the columns of `sm`?\n\n\n## Sparse matricies ‚å®Ô∏è\nHow can we calculate the sum of the columns of `sm`?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# find column sums of sparse\ncolSums(sm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 1 0 1 0\n```\n\n\n:::\n:::\n\n\n\n## Base R subsetting ‚å®Ô∏è {.nonincremental}\n* Basic R concepts for subsetting and referencing columns are important in single cell analysis\n* Vectors can be subset by index (position), logical vector (`c(TRUE, FALSE)`) or name (if vector is named)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract 2nd, 4th, and 6th entry\nletters[c(2, 4, 6)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"b\" \"d\" \"f\"\n```\n\n\n:::\n:::\n\n\n\n## Base R subsetting ‚å®Ô∏è\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# subset by creating logical vector\nvowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\")\nis_a_vowel <- letters %in% vowels\n\nletters[is_a_vowel]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"e\" \"i\" \"o\" \"u\"\n```\n\n\n:::\n:::\n\n\n\n## Base R subsetting ‚å®Ô∏è\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# name the letters vector with uppercase LETTERS\nnames(letters) <- LETTERS\n\n# subset by name\nletters[c(\"A\", \"Z\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  A   Z \n\"a\" \"z\" \n```\n\n\n:::\n:::\n\n\n\n## Base R subsetting ‚å®Ô∏è\n* Matrices are 2 dimensional vectors and have similar subsetting rules except there are two dimensions, rows and columns.\n\n`matrix[rows_to_subset, columns_to_subset]`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:24, nrow = 6)\n\n# extract 2nd, 4th, and 6th row\nm[c(2, 4, 6), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    8   14   20\n[2,]    4   10   16   22\n[3,]    6   12   18   24\n```\n\n\n:::\n:::\n\n\n\n## Base R subsetting ‚å®Ô∏è\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract 2nd and 4th column\nm[, c(2, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    7   19\n[2,]    8   20\n[3,]    9   21\n[4,]   10   22\n[5,]   11   23\n[6,]   12   24\n```\n\n\n:::\n:::\n\n\n\n## Base R subsetting ‚å®Ô∏è\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first 3 rows and 2nd and 4th column\nm[1:3, c(2, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    7   19\n[2,]    8   20\n[3,]    9   21\n```\n\n\n:::\n:::\n\n\n\n## Base R subsetting ‚å®Ô∏è\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract rows with totals > 50\nm[rowSums(m) > 50, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    4   10   16   22\n[2,]    5   11   17   23\n[3,]    6   12   18   24\n```\n\n\n:::\n:::\n\n\n\n## Base R subsetting ‚å®Ô∏è\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract columns with minimum values < 8\nm[, colMins(m) < 8]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    7\n[2,]    2    8\n[3,]    3    9\n[4,]    4   10\n[5,]    5   11\n[6,]    6   12\n```\n\n\n:::\n:::\n\n\n\n## Base R subsetting ‚å®Ô∏è\nThe base R `data.frame` and Bioconductor `DataFrame` can also be subset with the `[` and we can reference individual vectors in a data.frame using `$`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first 3 rows and columns of mtcars data.frame\nmtcars[1:3, 1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               mpg cyl disp\nMazda RX4     21.0   6  160\nMazda RX4 Wag 21.0   6  160\nDatsun 710    22.8   4  108\n```\n\n\n:::\n:::\n\n\n\n## Base R subsetting ‚å®Ô∏è\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# columns can be referenced using $, which extracts a vector\nmtcars$mpg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n```\n\n\n:::\n:::\n\n\n\n## Base R subsetting ‚å®Ô∏è\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# columns can be generated or overwritten using $ with assignment\nmtcars$new_column_name <- \"Hello!\"\nmtcars$wt <- mtcars$wt * 1000\n\n# We can subset using logical vectors\n# E.g. filter for rows (cars) with mpg > 20\nmtcars[mtcars$mpg > 20, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl  disp  hp drat   wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3215 19.44  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2780 18.60  1  1    4    2\n               new_column_name\nMazda RX4               Hello!\nMazda RX4 Wag           Hello!\nDatsun 710              Hello!\nHornet 4 Drive          Hello!\nMerc 240D               Hello!\nMerc 230                Hello!\nFiat 128                Hello!\nHonda Civic             Hello!\nToyota Corolla          Hello!\nToyota Corona           Hello!\nFiat X1-9               Hello!\nPorsche 914-2           Hello!\nLotus Europa            Hello!\nVolvo 142E              Hello!\n```\n\n\n:::\n:::\n\n\n\n\n## Read in Alevin output with tximport {.smaller}\n* Now that we know how to work with a sparse matrix, let's read in our data\n* `tximport` has methods for importing the binary data from alevin\n* We need to supply a path to the `quants_mat.gz` file. \n* If you want to load multiple samples use iteration approaches (e.g. `lapply`, `purrr::map`, a `for` loop). \n* Also note that the [`eds`](https://bioconductor.org/packages/release/bioc/html/eds.html) package was installed which greatly speeds up the loading of the matrix.\n\nWe will load in data from a 10x Genomics scRNA-seq library generated from human periperhal blood mononuclear cells (PMBCS). \n\n## Read in Alevin output with tximport ‚å®Ô∏è\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tximport)\ntx <- tximport(\n  here(\"data/block-rna/scrna/pbmc/alevin/quants_mat.gz\"),\n  type = \"alevin\"\n)\nnames(tx)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"abundance\"           \"counts\"              \"countsFromAbundance\"\n```\n\n\n:::\n:::\n\n\n\n`tx` is a list with 3 elements, `abundance`, `counts`, and `countsFromAbundance`. Let's look at the counts element\n\n## Read in Alevin output with tximport ‚å®Ô∏è\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- tx$counts\nmat[5:10, 1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6 x 3 sparse Matrix of class \"dgCMatrix\"\n                GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ATTTCTGTCTCTATGT\nENSG00000243485                .                .                .\nENSG00000284332                .                .                .\nENSG00000237613                .                .                .\nENSG00000268020                .                .                .\nENSG00000290826                .                .                .\nENSG00000240361                .                .                .\n```\n\n\n:::\n:::\n\n\n\nHere you can see that `tx$counts` is a sparse matrix that is genes (rows) by cells (columns).\n\nHow many barcodes are in `tx$counts`? How many genes?\n\n## Read in Alevin output with tximport ‚å®Ô∏è\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# TODO Find number of barcodes and genes in tx$counts\ndim(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 62266  6075\n```\n\n\n:::\n:::\n\n\n\n\nWhat fraction of the matrix is non-zero? We can use the `nnzero` function from the `Matrix` package check\n\n## Read in Alevin output with tximport ‚å®Ô∏è\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnnzero(mat) / length(mat) # (length = # of rows X # of columns)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.03282941\n```\n\n\n:::\n\n```{.r .cell-code}\n# similarily\nsum(mat > 0) / length(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.03282941\n```\n\n\n:::\n:::\n\n\n\n## Single cell analysis packages\n\n\nKey resource for single cell analysis in Bioconductor:\n[Orchestrating Single Cell Analysis](https://bioconductor.org/books/release/OSCA/)\n\n[`SingleCellExperiment`](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html) is the core datastructure for storing single cell data.\n\n[`scran`](https://bioconductor.org/packages/release/bioc/html/scran.html) provides algorithms for low-level processing of single cell data.\n\n[`scater`](https://bioconductor.org/packages/release/bioc/html/scater.html) provides plotting, data transformation, and quality control functionality\n\n\n## SingleCellExperiment\n\n![](../img/block-rna/sce.png)\n\n## Create a SingleCellExperiment object ‚å®Ô∏è {.smaller}\n A `SingleCellExperiment` object can be created from our sparse matrix using the `SingleCellExperiment()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- SingleCellExperiment(list(counts = mat))\nsce\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: SingleCellExperiment \ndim: 62266 6075 \nmetadata(0):\nassays(1): counts\nrownames(62266): ENSG00000290825 ENSG00000223972 ... ENSG00000210195\n  ENSG00000210196\nrowData names(0):\ncolnames(6075): GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ... ACGTAGGGTGACAGCA\n  TCTCAGCTCGCCGAAC\ncolData names(0):\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n\n\n## Exploring the SingleCellExperiment object ‚å®Ô∏è {.smaller}\nThe `SingleCellExperiment` object stores the gene x cell count matrix within `assays()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get list of assays\nassays(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of length 1\nnames(1): counts\n```\n\n\n:::\n\n```{.r .cell-code}\n# extract single assay\nassay(sce, \"counts\")[1:4, 1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4 x 4 sparse Matrix of class \"dgCMatrix\"\n                GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ATTTCTGTCTCTATGT\nENSG00000290825                .                .                .\nENSG00000223972                .                .                .\nENSG00000227232                .                .                .\nENSG00000278267                .                .                .\n                TATCTGTAGGTGATAT\nENSG00000290825                .\nENSG00000223972                .\nENSG00000227232                .\nENSG00000278267                .\n```\n\n\n:::\n:::\n\n\n\n## Exploring the SingleCellExperiment object ‚å®Ô∏è\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassays(sce)$counts[1:4, 1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4 x 4 sparse Matrix of class \"dgCMatrix\"\n                GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ATTTCTGTCTCTATGT\nENSG00000290825                .                .                .\nENSG00000223972                .                .                .\nENSG00000227232                .                .                .\nENSG00000278267                .                .                .\n                TATCTGTAGGTGATAT\nENSG00000290825                .\nENSG00000223972                .\nENSG00000227232                .\nENSG00000278267                .\n```\n\n\n:::\n:::\n\n\n\n## Exploring the SingleCellExperiment object ‚å®Ô∏è\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# convenience function for counts assay\ncounts(sce)[1:4, 1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4 x 4 sparse Matrix of class \"dgCMatrix\"\n                GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ATTTCTGTCTCTATGT\nENSG00000290825                .                .                .\nENSG00000223972                .                .                .\nENSG00000227232                .                .                .\nENSG00000278267                .                .                .\n                TATCTGTAGGTGATAT\nENSG00000290825                .\nENSG00000223972                .\nENSG00000227232                .\nENSG00000278267                .\n```\n\n\n:::\n:::\n\n\n\n## Accessing cell metadata ‚å®Ô∏è\n* We generate cell-level information\n - such as quality control metrics, clustering results, and celltype assignments. \n* This data is stored within a data frame called `colData`\n* access using `colData()`\n* Specialized Bioconductor specific data.frame class (`DataFrame`) which has similar semantics and functionality to a base R data.frame. \n\n## Accessing cell metadata ‚å®Ô∏è {.smaller}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# empty right now.\ncolData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 6075 rows and 0 columns\n```\n\n\n:::\n\n```{.r .cell-code}\n# add a sample annotation\ncolData(sce)$cell_source <- \"PBMC\"\n\n# equivalent approach using $\nsce$cell_source <- \"PBMC\"\n\ncolData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 6075 rows and 1 column\n                 cell_source\n                 <character>\nGCTGCAGTCCGATCTC        PBMC\nACTATGGAGGTCCCTG        PBMC\nATTTCTGTCTCTATGT        PBMC\nTATCTGTAGGTGATAT        PBMC\nAGCCAGCCAAAGCACG        PBMC\n...                      ...\nCATCCCAAGTACTCGT        PBMC\nCTCCTCCCATGAAGCG        PBMC\nAGTTCCCCATGTCAGT        PBMC\nACGTAGGGTGACAGCA        PBMC\nTCTCAGCTCGCCGAAC        PBMC\n```\n\n\n:::\n:::\n\n\n\n## Accessing gene metadata ‚å®Ô∏è\n* Gene-level metadata is stored in a data.frame called `rowData()`. \n* Use the rowData to store gene ids, symbols, and other information about genes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# empty right now\nrowData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 62266 rows and 0 columns\n```\n\n\n:::\n:::\n\n\n\n## Manipulating a SingleCellExperiment ‚å®Ô∏è\n\n* Calculate the total number of counts in each cell and store these counts in the `colData().*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce$total_counts <- colSums(counts(sce))\n```\n:::\n\n\n\n## Manipulating a SingleCellExperiment ‚å®Ô∏è {.smaller}\n\n* Calculate the total number of counts for each gene, summed across cells \n* Calculate the number of cells with > 0 counts per gene\n* store both of these values in the rowData(). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowData(sce)$total_gene_counts <- rowSums(counts(sce))\nrowData(sce)$n_cells_expr <- rowSums(counts(sce) > 0)\nrowData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 62266 rows and 2 columns\n                total_gene_counts n_cells_expr\n                        <numeric>    <integer>\nENSG00000290825         65.594607           43\nENSG00000223972          0.000000            0\nENSG00000227232          5.506349           24\nENSG00000278267          0.000000            0\nENSG00000243485          0.333333            1\n...                           ...          ...\nENSG00000198695              2054         1509\nENSG00000210194                 0            0\nENSG00000198727            274421         5704\nENSG00000210195                 0            0\nENSG00000210196                 0            0\n```\n\n\n:::\n:::\n\n\n\n## Manipulating a SingleCellExperiment ‚å®Ô∏è\n* We can subset the SingleCellExperiment using the same techniques as base R data.\n* Note that `dplyr` verbs do not work with `SingleCellExperiment`\n\n```r\ndata.frame[rows, columns]\n\nsce[genes, cells]\n```\n\n## Manipulating a SingleCellExperiment ‚å®Ô∏è {.smaller}\n* We can subset the SingleCellExperiment using the same techniques as base R data.\n* Note that `dplyr` verbs do not work with `SingleCellExperiment`\n\n```r\n# subset to data from first 4 genes and cells\nsce[1:4, 1:4]\n\n# subset to cells from PBMC cells\nsce[, sce$cell_source == \"PBMC\"]\n\n\ngenes_to_keep <- c(\"ENSG00000223972\", \"ENSG00000210195\", \"ENSG00000210196\")\nsce[genes_to_keep, ]\n\ncells_to_keep <- c(\"ACTATGGAGGTCCCTG\", \"GCTGCAGTCCGATCTC\", \"TCTCAGCTCGCCGAAC\")\nsce[, cells_to_keep]\n```\n\n## Manipulating a SingleCellExperiment \n`ncol()`: # of cells  \n`nrow()`: # of gene  \n`dims()`: # of genes and cells  \n`rownames()`: rownames in matrices (e.g. genes)  \n`colnames()`: colnames in matrices (e.g. cells)   \n`cbind()`: combine multiple SingleCellExperiments by column  \n`rbind()`: combine multiple SingleCellExperiments by row  \n\n## Storing gene identifiers \n* Ensembl gene ids are the rownames of our matrix (e.g. ENSG00000289576, ENSG00000221539). \n* These identifiers are guaranteed to be unique and are more stable and reliable than gene symbols (e.g. ACTB, GAPDH).\n* This becomes important if you want to compare to external datasets or ensure that your data can be easily used by others in the future.\n* But they aren't easy to interpret\n\n\n## Storing gene identifiers ‚å®Ô∏è {.smaller}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nah <- AnnotationHub()\n# download ensembl database\nens_db <- ah[[\"AH113665\"]]\n\ngene_names <- mapIds(ens_db,\n  keys = rownames(sce),\n  keytype = \"GENEID\",\n  column = \"SYMBOL\"\n)\n\nrowData(sce)$gene <- gene_names\nrowData(sce)$gene_id <- rownames(sce)\nrowData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 62266 rows and 4 columns\n                total_gene_counts n_cells_expr        gene         gene_id\n                        <numeric>    <integer> <character>     <character>\nENSG00000290825         65.594607           43     DDX11L2 ENSG00000290825\nENSG00000223972          0.000000            0     DDX11L1 ENSG00000223972\nENSG00000227232          5.506349           24      WASH7P ENSG00000227232\nENSG00000278267          0.000000            0   MIR6859-1 ENSG00000278267\nENSG00000243485          0.333333            1 MIR1302-2HG ENSG00000243485\n...                           ...          ...         ...             ...\nENSG00000198695              2054         1509      MT-ND6 ENSG00000198695\nENSG00000210194                 0            0       MT-TE ENSG00000210194\nENSG00000198727            274421         5704      MT-CYB ENSG00000198727\nENSG00000210195                 0            0       MT-TT ENSG00000210195\nENSG00000210196                 0            0       MT-TP ENSG00000210196\n```\n\n\n:::\n:::\n\n\n\n## Updating our rownames ‚å®Ô∏è {.smaller}\n* Goal rename rownames to symbols\n* Problem, some are ` `, `NA`, or duplicated\n* `uniquifyFeatureNames()` is a convenience function that will rename gene symbols that are `NA` or duplicated values to the ensembl ID or a combination of gene symbol and ensembl ID\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(sce) <- uniquifyFeatureNames(\n  rowData(sce)$gene_id,\n  rowData(sce)$gene\n)\nhead(rownames(sce))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"DDX11L2_ENSG00000290825\" \"DDX11L1\"                \n[3] \"WASH7P\"                  \"MIR6859-1\"              \n[5] \"MIR1302-2HG\"             \"MIR1302-2\"              \n```\n\n\n:::\n:::\n\n\n\n## Filtering low quality cells ‚å®Ô∏è {.smaller}\nNext we perform some filtering and quality control to remove low expression genes and poor quality cells.\n \nOur SingleCellExperiment has 62266 genes in the matrix. Most of these are\nnot expressed. We want to exclude these genes as they won't provide any useful\ndata for the analysis. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# exclude genes expressed in fewer than 10 cells (~ 1% of cells)\nrowData(sce)$n_cells <- rowSums(counts(sce) > 0)\nsce <- sce[rowData(sce)$n_cells >= 10, ]\nsce\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: SingleCellExperiment \ndim: 20858 6075 \nmetadata(0):\nassays(1): counts\nrownames(20858): DDX11L2_ENSG00000290825 WASH7P ... MT-ND6 MT-CYB\nrowData names(5): total_gene_counts n_cells_expr gene gene_id n_cells\ncolnames(6075): GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ... ACGTAGGGTGACAGCA\n  TCTCAGCTCGCCGAAC\ncolData names(2): cell_source total_counts\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n\n\n## Filtering low quality cells\nTo exclude low-quality cells we will use the following metrics:\n\n* Number of counts per cell barcode\n* Number of genes detected per barcode\n* The percentage of counts from mitochondrial genes per barcode\n\nA low number of counts, a low number of detected genes, and a high percentage of mitochondrial counts suggests that the cell had a broken membrane and the cytoplasmic mRNA leaked out. \n\n\n## Filtering low quality cells ‚å®Ô∏è {.smaller}\n\nTo calculate these metrics we can use `addPerCellQCMetrics` from scater. Mitochondrial genes are named with a common \"MT-\" prefix (e.g. MT-CO2, MT-ATP6, MR-RNR2), which we can use to identify them.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# identify subset of genes that are from mitochondrial genome\nis_mito <- startsWith(rowData(sce)$gene, \"MT-\")\nsce <- addPerCellQCMetrics(sce, subsets = list(Mito = is_mito))\ncolData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 6075 rows and 8 columns\n                 cell_source total_counts       sum  detected subsets_Mito_sum\n                 <character>    <numeric> <numeric> <integer>        <numeric>\nGCTGCAGTCCGATCTC        PBMC        31924   31908.0      5718          2668.49\nACTATGGAGGTCCCTG        PBMC        35845   35801.5      6073          3963.23\nATTTCTGTCTCTATGT        PBMC        31788   31758.3      6377          2496.33\nTATCTGTAGGTGATAT        PBMC        32025   31998.0      6260          2961.15\nAGCCAGCCAAAGCACG        PBMC        29882   29856.0      5746          2660.44\n...                      ...          ...       ...       ...              ...\nCATCCCAAGTACTCGT        PBMC          151   151.000       132               12\nCTCCTCCCATGAAGCG        PBMC          133   132.500       131                6\nAGTTCCCCATGTCAGT        PBMC          173   172.667       166                8\nACGTAGGGTGACAGCA        PBMC          255   253.000       217               13\nTCTCAGCTCGCCGAAC        PBMC          144   144.000       149                4\n                 subsets_Mito_detected subsets_Mito_percent     total\n                             <integer>            <numeric> <numeric>\nGCTGCAGTCCGATCTC                    13              8.36307   31908.0\nACTATGGAGGTCCCTG                    15             11.07002   35801.5\nATTTCTGTCTCTATGT                    15              7.86038   31758.3\nTATCTGTAGGTGATAT                    15              9.25417   31998.0\nAGCCAGCCAAAGCACG                    15              8.91092   29856.0\n...                                ...                  ...       ...\nCATCCCAAGTACTCGT                     5              7.94702   151.000\nCTCCTCCCATGAAGCG                     5              4.52830   132.500\nAGTTCCCCATGTCAGT                     6              4.63320   172.667\nACGTAGGGTGACAGCA                     6              5.13834   253.000\nTCTCAGCTCGCCGAAC                     2              2.77778   144.000\n```\n\n\n:::\n:::\n\n\n\n## Filtering low quality cells ‚å®Ô∏è\nWe can use the `plotColData()` function from scater to plot various metrics (as a ggplot2 object). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotColData(sce, y = \"sum\")\n```\n\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/unnamed-chunk-36-1.png){width=864}\n:::\n:::\n\n\n\n## Filtering low quality cells ‚å®Ô∏è\nWe can use the `plotColData()` function from scater to plot various metrics (as a ggplot2 object). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotColData(sce, y = \"detected\")\n```\n\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/unnamed-chunk-37-1.png){width=864}\n:::\n:::\n\n\n\n## Filtering low quality cells ‚å®Ô∏è\nWe can use the `plotColData()` function from scater to plot various metrics (as a ggplot2 object). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotColData(sce, y = \"detected\", x = \"sum\", \n            colour_by = \"subsets_Mito_percent\")\n```\n\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/unnamed-chunk-38-1.png){width=864}\n:::\n:::\n\n\n\n## Filtering low quality cells ‚å®Ô∏è\nWe can use the `plotColData()` function from scater to plot various metrics (as a ggplot2 object). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotColData(sce, y = \"subsets_Mito_percent\", x = \"sum\") +\n  labs(x = \"# of counts\")\n```\n\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/unnamed-chunk-39-1.png){width=864}\n:::\n:::\n\n\n\n## Filtering low quality cells ‚å®Ô∏è\nWe can also extract `colData` as a dataframe to make custom `ggplot2` plots\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncell_info <- as.data.frame(colData(sce))\nggplot(cell_info, aes(sum, subsets_Mito_percent)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/unnamed-chunk-40-1.png){width=864}\n:::\n:::\n\n\n\n## Filtering low quality cells ‚å®Ô∏è\n\n* Selecting an appropriate cutoff can be somewhat arbitrary\n* Risk of excluding meaningful cell populations.\n* Start with lenient cutoffs, then later increasing the stringency after examining the clustering and cell types.  \n\n *How many cells pass these criteria?*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npass_qc <- sce$subsets_Mito_percent < 20 & \n  sce$detected > 500 & \n  sce$sum > 1000\n```\n:::\n\n\n\n*How many cells pass these criteria?*\n\n## Filtering low quality cells ‚å®Ô∏è\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(pass_qc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4565\n```\n\n\n:::\n:::\n\n\n\n## Visualizing qc failed cells ‚å®Ô∏è\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce$pass_qc <- sce$subsets_Mito_percent < 20 & \n  sce$detected > 500 & \n  sce$sum > 1000\n\nplotColData(sce,\n  y = \"subsets_Mito_percent\",\n  x = \"sum\",\n  colour_by = \"pass_qc\"\n) +\n  labs(x = \"# of counts\")\n```\n\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/unnamed-chunk-43-1.png){width=864}\n:::\n:::\n\n\n\n## Remove low quality cells ‚å®Ô∏è\nLastly we can subset the `SingleCellExperiment` to exclude the low-quality cells. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- sce[, sce$pass_qc]\nsce\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: SingleCellExperiment \ndim: 20858 4565 \nmetadata(0):\nassays(1): counts\nrownames(20858): DDX11L2_ENSG00000290825 WASH7P ... MT-ND6 MT-CYB\nrowData names(5): total_gene_counts n_cells_expr gene gene_id n_cells\ncolnames(4565): GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ... CTGGATCCACCGTACG\n  TACAACGGTCTCGCGC\ncolData names(9): cell_source total_counts ... total pass_qc\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n\n\n## Analysis workflow\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"grViz html-widget html-fill-item\" id=\"htmlwidget-693aba093e74df827697\" style=\"width:100%;height:100%;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-693aba093e74df827697\">{\"x\":{\"diagram\":\"\\ndigraph workflow {\\n  graph [layout = dot,\\n         rankdir = LR]\\n\\n  node [shape = cicle,\\n        style = filled,\\n        fontcolor = black,\\n        fontname = \\\"Helvetica\\\"]\\n\\n  # green\\n  node [fillcolor = \\\"#009E73\\\"]\\n  load [label= \\\"Import data\\ntximport::tximport()\\nSingleCellExperiment()\\ncounts()\\\"]\\n\\n  # blue\\n  node [fillcolor = \\\"#56B4E9\\\"]\\n  cell_qc [label = \\\"QC cells\\n addPerCellQCMetrics()\\n plotColData()\\\"]\\n  norm [label = \\\"Normalize UMI counts\\nquickCluster()\\n computeSumFactors()\\n logNormCounts()\\\"]\\n\\n  # yellow\\n  node [fillcolor = \\\"#F0E442\\\"]\\n  feature [label = \\\"Identify variable genes\\nmodelGeneVarByPoisson()\\n getTopHVGs()\\\"]\\n  dim_red [label = \\\"Dimensionality reduction via PCA \\n runPCA()\\\"]\\n  cluster [label = \\\"Clustering\\n clusterCells()\\\"]\\n  viz [label = \\\"Make 2D-Visualization\\nrunUMAP()\\\"]\\n\\n  # blue\\n  node [fillcolor = \\\"#56B4E9\\\"]\\n\\n  markers [label = \\\"Discover cell type markers \\nscoreMarkers()\\\"]\\n  annot [label = \\\"Annotate cell types\\nclustifyr and SingleR\\\"]\\n\\n  edge [color = black\\n        fontname = \\\"Helvetica\\\"]\\n\\n  load -> cell_qc\\n  cell_qc -> norm\\n  norm -> feature\\n  norm -> markers\\n  feature -> dim_red\\n  dim_red -> cluster\\n  dim_red -> viz\\n  cluster -> markers\\n  markers -> annot\\n\\n  edge [color = \\\"grey\\\"\\n        style = \\\"dashed\\\"]\\n  annot -> cell_qc [label = \\\"Repeat\\n as needed\\\"]\\n  annot -> feature\\n  annot -> dim_red\\n  annot -> cluster\\n}\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n## Normalization ‚å®Ô∏è\n* Normalization attempts to correct for technical biases that will distort biological signal in the data. \n* A large source of variation arises due to differences in sequencing depth between cells. \n* This can be seen by performing PCA on the unnormalized counts. \n* We will use `runPCA` from scater to perform PCA. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set seed for functions with a randomized component\n# to obtain the same result each execution\nset.seed(20231023)\nsce <- runPCA(sce, exprs_values = \"counts\", name = \"count_PCA\")\n```\n:::\n\n\n\n## Normalization ‚å®Ô∏è {.smaller}\n\n::: columns\n::: {.column width=\"70%\"}\n* We can now visualize this PCA\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotReducedDim(sce, \"count_PCA\", colour_by = \"sum\")\n```\n\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"3%\"}\n\n:::\n\n::: {.column width=\"27%\"}\n\n\nNote that PC1 is correlated with the total UMI counts (`sum`), meaning that the largest source of variation is related to differences in sequencing depth rather than biological differences between cells. \n\n:::\n:::\n\n## Normalization ‚å®Ô∏è\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_df <- makePerCellDF(sce, c(\"count_PCA\", \"sum\"))\n\nggplot(plot_df, aes(count_PCA.1, sum)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/unnamed-chunk-48-1.png){width=960}\n:::\n:::\n\n\n\n## Normalization ‚å®Ô∏è\n* Normalize with `scran`\n1. Crude clustering to group related cells\n2. Identifying a cell-specific normalization factor (size factor)\n3. Scaling the counts by this factor \n4. log transforming the data (base 2 with a pseudocount). \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(20231023)\nclusters <- quickCluster(sce)\nsce <- computeSumFactors(sce, clusters = clusters)\nsce <- logNormCounts(sce)\n```\n:::\n\n\n\n::: footer\nDescription of algorithim:\nLun AT, Bach K, Marioni JC. Pooling across cells to normalize single-cell RNA sequencing data with many zero counts. Genome Biol. 2016 Apr 27;17:75. doi: 10.1186/s13059-016-0947-7. PMID: 27122128; PMCID: PMC4848819.\n:::\n\n## Normalization ‚å®Ô∏è\nPlot the PCA with normalization\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(20231023)\nsce <- runPCA(sce, exprs_values = \"logcounts\", name = \"PCA\")\nplotReducedDim(sce, \"PCA\", colour_by = \"sum\")\n```\n\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/unnamed-chunk-50-1.png){width=960}\n:::\n:::\n\n\n\n## Normalization ‚å®Ô∏è\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_df <- makePerCellDF(sce, c(\"PCA\", \"sum\"))\nggplot(plot_df, aes(PCA.1, sum)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](slides-31_files/figure-revealjs/unnamed-chunk-51-1.png){width=960}\n:::\n:::\n\n\n\nPC1 no longer correlates with UMI counts.\n\n## Further Reading \n\neBook: Orchestrating single cell analyses with Bioconductor [eBook](https://osca.bioconductor.org/) [Publication](https://doi.org/10.1038/s41592-019-0654-x)\n\nReview: [Current best practices for analysis](https://www.embopress.org/doi/full/10.15252/msb.20188746) \n\nBlog: [Single Cell Thoughts](https://ltla.github.io/SingleCellThoughts/)  \n\nBlog: [What do you mean \"heterogeneity\"](http://www.nxn.se/)  \n\n\n",
    "supporting": [
      "slides-31_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"../site_libs/viz-1.8.2/viz.js\"></script>\n<link href=\"../site_libs/DiagrammeR-styles-0.2/styles.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/grViz-binding-1.0.11/grViz.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}