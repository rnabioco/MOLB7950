{
  "hash": "2aaa0cfbe56b5f350ae35575b5de593a",
  "result": {
    "markdown": "---\ntitle: \"Mapping chromatin structure and transactions\"\nauthor: \"Jay Hesselberth\"\n---\n\n\n## Gene regulation by chromatin\n\n::: {layout-ncol=3 layout-valign=\"center\"}\n![Genome organization](../img/block-dna/ctcf.jpg)\n\n![Cell signaling](../img/block-dna/promoter.png)\n\n![Organism development](../img/block-dna/org-dev.jpg)\n:::\n\n## DNA accessibility drives all biochemical transactions on the genome\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n-   Transcription Initiation\n-   Transcription Elongation\n-   DNA Repair\n-   Initiation of DNA Replication\n-   Recombination\n-   Viral Integration\n:::\n::: {.column width=\"50%\"}\n![](../img/block-dna/domino.gif)\n:::\n::::\n\n## Mapping & measurement are first steps toward understanding. {.smaller}\n\n:::: {.columns}\n::: {.column width=\"60%\"}\nBefore genome-wide DNA accessibility measurements, we knew about chromatin transactions at only a handful of loci.\n\nThis was a classic \"keys under the lamppost\" situation, leading to general models of chromatin-based gene regulation.\n:::\n\n::: {.column width=\"40%\"}\n![](../img/block-dna/street-lamp.jpg){width=\"100%\"}\n:::\n::::\n\n::: aside\nPhoto by [Justus Menke](https://unsplash.com/@justusmenke?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/photos/PvQtCNm4teI?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n:::\n\n## Using micrococcal nuclease (MNase) to map chromatin {.smaller}\n\n:::: {.columns}\n::: {.column width=\"50%\" .nonincremental}\n-   Micrococcal nuclease is an endo/exonuclease from *Staphylococcus aureus*\n-   Efficient, **multiple turnover** enzyme that digests accessible DNA (& RNA)\n-   Dependent on calcium (Ca2+)\n:::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/mnase-overview.png){fig-align=\"center\"}\n:::\n::::\n\n## Using ATAC to map chromatin {.smaller}\n\n:::: {.columns}\n::: {.column width=\"50%\" .nonincremental}\n-   Tn5 transposase catalyzes \"cut-and-paste\" insertion of DNA into a target\n-   In ATAC (\"Assay for Transposase-Accessible Chromatin\"), the transposase enzymes are loaded with DNA sequencing adaptors (blue and red in the image), so the products of transposition are ready to PCR.\n-   **Single turnover enzyme** that acts on accessible DNA.\n:::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/atac-explain.png){fig-align=\"center\"}\n:::\n::::\n\n## **Chromatin mapping experimental summary** {.smaller}\n\n|                           |                     DNase-seq                     |                                                       ATAC-seq                                                        |             MNase-seq              |\n|------------------|:----------------:|:----------------:|:-----------------:|\n| **Genome representation** |                Most active regions                |                                                  Most active regions                                                  |            Whole genome            |\n| **Ease of experiment**    |                  Very difficult                   |                                                      Easy peasy                                                       |           One day's work           |\n| **What is profiled?**     | Accessible DNA, \"footprints\" at low cut frequency | Accessible DNA. Not really \"footprints\" (see Tn5 structure), single turnover enzyme, so fragments are not informative | Protections of TFs and nucleosomes |\n\n# Experimental details\n\n## \n\n![](../img/block-dna/footprinting-exp-overview.png)\n\n## \n\n![](../img/block-dna/atac-input-comparison.png)\n\n# Analysis details\n\n## Experimental workflow \n\n![](../img/block-dna/exp-outline.png)\n\n# Data structures and tools used for analysis of chromatin mapping experiments\n\n## File formats \n\n### BED format {.smaller}\n\n:::: {.columns}\n::: {.column width=\"50%\" .nonincremental}\n- Contains information about genomic intervals. \n- Used to represent genomic features (exons, introns, transcription start sites)\n- First 3 columns are: `chrom`, `start`, `end`\n- Next 3 are: `name`, `score`, `strand`. Strand can be `+`, `-`, or `.` (no strand)\n:::\n\n::: {.column width=\"50%\"}\n```\nchr7 127473530 127474697 Pos3 0  +\nchr7 127474697 127475864 Pos4 0  +\nchr7 127475864 127477031 Neg1 0  -\nchr7 127477031 127478198 Neg2 0  -\n```\n:::\n::::\n\n---\n\n### wig / bedGraph {.smaller}\n\n- Used to store interval *signals*.\n\n  * Genome sequencing coverage\n  * Coverage of reads from MNase / ATAC-seq\n  \n- bigWig is a binary form of WIG, used to store large amounts of signal\nin a compressed, indexed format.\n\n- Many studies will provide genome-scale data in these formats\n\n## Interval analysis {.smaller}\n\nThe primary tool in the genome interval analysis is [BEDtools](https://bedtools.readthedocs.io/en/latest/) -- it's the \nSwiss-army knife of internal analysis. \n\nWe wrote an R package called [valr](https://rnabioco.github.io/valr/) that provides the same tools, but you don't need to \nleave RStudio. \n\nvalr contains tools for reading and manipulating genome intervals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(valr)\n\nsnps <- read_bed(\n  valr_example(\"hg19.snps147.chr22.bed.gz\"),\n  n = 6\n)\n\ngenes <- read_bed(\n  valr_example(\"genes.hg19.chr22.bed.gz\"),\n  n = 6\n)\n```\n:::\n\n\n## {.smaller}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\nsnps\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 x 6\n   chrom    start      end name        score strand\n   <chr>    <int>    <int> <chr>       <chr> <chr> \n 1 chr22 16053247 16053248 rs587721086 0     +     \n 2 chr22 16053443 16053444 rs80167676  0     +     \n 3 chr22 16055964 16055965 rs587706951 0     +     \n 4 chr22 16069373 16069374 rs2154787   0     +     \n 5 chr22 16069782 16069783 rs1963212   0     +     \n 6 chr22 16100513 16100514 rs8140563   0     +     \n 7 chr22 16114622 16114623 rs558374111 0     +     \n 8 chr22 16115181 16115182 rs567521927 0     +     \n 9 chr22 16115377 16115378 rs538733846 0     +     \n10 chr22 16121639 16121640 rs544560983 0     +     \n# i 9,990 more rows\n```\n\n\n:::\n:::\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\ngenes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 732 x 6\n   chrom    start      end name      score strand\n   <chr>    <int>    <int> <chr>     <chr> <chr> \n 1 chr22 16150259 16193004 AK022914  8     -     \n 2 chr22 16162065 16172265 LINC00516 3     +     \n 3 chr22 16179617 16181004 BC017398  1     -     \n 4 chr22 16239287 16239327 DQ590589  1     +     \n 5 chr22 16240245 16240277 DQ573684  1     -     \n 6 chr22 16240300 16240340 DQ595048  1     -     \n 7 chr22 16241085 16241125 DQ590589  1     +     \n 8 chr22 16242753 16242785 DQ573684  1     -     \n 9 chr22 16243382 16243414 DQ573684  1     -     \n10 chr22 16243447 16243487 DQ587539  1     -     \n# i 722 more rows\n```\n\n\n:::\n:::\n\n\n## Interval manipulation {.smaller}\n\nLet's find and characterize intergenic SNPs. We'll use the tools `bed_substract()` and `bed_closest()`. Take a look and their examples in the documentation to see what they do.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# find snps in intergenic regions\nintergenic <- bed_subtract(snps, genes)\n\n# find distance from intergenic snps to nearest gene\nnearby <- bed_closest(intergenic, genes)\n```\n:::\n\n\n## Interval manipulation {.smaller}\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nnearby |>\n  select(starts_with(\"name\"), .overlap, .dist) |>\n  filter(abs(.dist) < 5000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,047 x 4\n   name.x      name.y   .overlap .dist\n   <chr>       <chr>       <int> <int>\n 1 rs530458610 P704P           0  2579\n 2 rs2261631   P704P           0  -268\n 3 rs570770556 POTEH           0  -913\n 4 rs538163832 POTEH           0  -953\n 5 rs190224195 POTEH           0 -1399\n 6 rs2379966   DQ571479        0  4750\n 7 rs142687051 DQ571479        0  3558\n 8 rs528403095 DQ571479        0  3309\n 9 rs555126291 DQ571479        0  2745\n10 rs5747567   DQ571479        0 -1778\n# i 1,037 more rows\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}