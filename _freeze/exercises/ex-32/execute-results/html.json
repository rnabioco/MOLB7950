{
  "hash": "24f68ff0249d9f99c70be61fc44ae5ad",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Single cell RNA-seq class 2\"\nauthor: \"Kent Riemondy\"\n---\n\n::: {.cell}\n\n:::\n\n\n\n## Analysis steps continued\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"grViz html-widget html-fill-item\" id=\"htmlwidget-9ae691950629f407e351\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-9ae691950629f407e351\">{\"x\":{\"diagram\":\"\\ndigraph workflow {\\n  graph [layout = dot,\\n         rankdir = TD]\\n\\n  node [shape = cicle,\\n        style = filled,\\n        fontcolor = black,\\n        fontname = \\\"Helvetica\\\"]\\n\\n  # green\\n  node [fillcolor = \\\"#009E73\\\"]\\n  load [label= \\\"Import data\\ntximport::tximport()\\nSingleCellExperiment()\\ncounts()\\\"]\\n\\n  # blue\\n  node [fillcolor = \\\"#56B4E9\\\"]\\n  cell_qc [label = \\\"QC cells\\n addPerCellQCMetrics()\\n plotColData()\\\"]\\n  norm [label = \\\"Normalize UMI counts\\nquickCluster()\\n computeSumFactors()\\n logNormCounts()\\\"]\\n\\n  # yellow\\n  node [fillcolor = \\\"#F0E442\\\"]\\n  feature [label = \\\"Identify variable genes\\nmodelGeneVarByPoisson()\\n getTopHVGs()\\\"]\\n  dim_red [label = \\\"Dimensionality reduction via PCA \\n runPCA()\\\"]\\n  cluster [label = \\\"Clustering\\n clusterCells()\\\"]\\n  viz [label = \\\"Make 2D-Visualization\\nrunUMAP()\\\"]\\n\\n  # blue\\n  node [fillcolor = \\\"#56B4E9\\\"]\\n\\n  markers [label = \\\"Discover cell type markers \\nscoreMarkers()\\\"]\\n  annot [label = \\\"Annotate cell types\\nclustifyr and SingleR\\\"]\\n\\n  edge [color = black\\n        fontname = \\\"Helvetica\\\"]\\n\\n  load -> cell_qc\\n  cell_qc -> norm\\n  norm -> feature\\n  norm -> markers\\n  feature -> dim_red\\n  dim_red -> cluster\\n  dim_red -> viz\\n  cluster -> markers\\n  markers -> annot\\n\\n  edge [color = \\\"grey\\\"\\n        style = \\\"dashed\\\"]\\n  annot -> cell_qc [label = \\\"Repeat\\n as needed\\\"]\\n  annot -> feature\\n  annot -> dim_red\\n  annot -> cluster\\n}\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n# Simplified steps\n\nMany of the steps involved in processing the data are executed using a succinct set of steps shown below. Much of our class today will be devoted to understanding the purpose of each of these steps and key parameters that can affect the results. \n\nNote that for many of these functions take a SingleCellExperiment as input, \nmodify the SingleCellExperiment, and return a SingleCellExperiment. Others return\na vector or data.frame. \n\n``` r\n# normalize data\nclusters <- quickCluster(sce)\nsce <- computeSumFactors(sce, clusters=clusters)\nsce <- logNormCounts(sce)\n\n# get variable genes\ndec <- modelGeneVarByPoisson(sce)\ntop <- getTopHVGs(dec, prop=0.1)\n\n# get PCA and UMAP\nsce <- runPCA(sce, subset_row = top)\nsce <- runUMAP(sce, dimred = \"PCA\")\n\n# cluster cells\nsce$clusters <- clusterCells(sce, use.dimred = \"PCA\")\n\n# get markers\nmrks <- scoreMarkers(sce, sce$clusters)\n\n```\n\n# Rerun steps from previous class\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load data\nlibrary(tximport)\ntx <- tximport(\n  here(\"data/block-rna/scrna/pbmc/alevin/quants_mat.gz\"),\n  type = \"alevin\"\n)\n\n# setup gene ids\nsce <- SingleCellExperiment(list(counts = tx$counts))\nah <- AnnotationHub()\nens_db <- ah[[\"AH113665\"]]\n\ngene_names <- mapIds(ens_db,\n  keys = rownames(sce),\n  keytype = \"GENEID\",\n  column = \"SYMBOL\"\n)\n\nrowData(sce)$gene <- gene_names\nrowData(sce)$gene_id <- rownames(sce)\nrownames(sce) <- uniquifyFeatureNames(\n  rowData(sce)$gene_id,\n  rowData(sce)$gene\n)\n\n# drop non/low expressed genes\nrowData(sce)$n_cells <- rowSums(counts(sce) > 0)\nsce <- sce[rowData(sce)$n_cells >= 10, ]\n\n# basic QC\nis_mito <- startsWith(rowData(sce)$gene, \"MT-\")\nsce <- addPerCellQCMetrics(sce, subsets = list(Mito = is_mito))\nsce$pass_qc <- sce$subsets_Mito_percent < 20 & sce$sum > 1000 & sce$detected > 500\n\n# subset data\nsce <- sce[, sce$pass_qc]\nsce\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: SingleCellExperiment \ndim: 20858 4565 \nmetadata(0):\nassays(1): counts\nrownames(20858): DDX11L2_ENSG00000290825 WASH7P ... MT-ND6 MT-CYB\nrowData names(3): gene gene_id n_cells\ncolnames(4565): GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ... CTGGATCCACCGTACG\n  TACAACGGTCTCGCGC\ncolData names(7): sum detected ... total pass_qc\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n\n\n\n## Normalizing data\n\nTo normalize we will use 3 functions from the scran package. The normalization entails crude clustering to group related cells, identifying a cell-specific normalization factor (size factor), then scaling the counts by this factor and log transforming the data (with a pseudocount). The algorithm is described in detail in the following paper and in the R documentation (`?scuttle::computePooledFactors`)\n\n>Lun AT, Bach K, Marioni JC. Pooling across cells to normalize single-cell RNA sequencing data with many zero counts. Genome Biol. 2016 Apr 27;17:75. doi: 10.1186/s13059-016-0947-7. PMID: 27122128; PMCID: PMC4848819.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set seed to obtain the same result on each execution of quickCluster\nset.seed(20231023)\nclusters <- quickCluster(sce) # returns vector of cluster assignments\nsce <- computeSumFactors(sce, clusters = clusters) # add \"sizeFactor\" to colData\nsce <- logNormCounts(sce) # adds new assay called logcounts\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlogcounts(sce)[50:60, 1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n11 x 4 sparse Matrix of class \"dgCMatrix\"\n           GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ATTTCTGTCTCTATGT TATCTGTAGGTGATAT\nCPTP              .                0.2645668        .                .        \nTAS1R3            .                .                .                .        \nDVL1              .                0.2645668        .                .        \nMXRA8             .                .                .                .        \nAURKAIP1          0.3500082        1.9327619        0.2923841        0.7922116\nCCNL2             0.6314635        .                0.7432885        0.5731981\nMRPL20-AS1        0.3500082        0.2645668        0.2923841        .        \nMRPL20            0.8668712        1.1425125        0.9249737        0.7922116\nRN7SL657P         .                .                .                .        \nMRPL20-DT         .                .                .                0.3148810\nATAD3C            .                .                .                .        \n```\n\n\n:::\n:::\n\n\n\n\n## Get variable genes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(00010101) # set seed to obtain the same result on each execution of modelGeneVarByPoisson\n\ndec <- modelGeneVarByPoisson(sce) # returns data.frame of statistics\n\ntop <- getTopHVGs(dec, prop = 0.1) # return vector of top 10% most variable genes\ntop[1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"LYZ\"     \"S100A9\"  \"S100A8\"  \"HLA-DRA\"\n```\n\n\n:::\n:::\n\n\n\nWe can plot the mean expression against variance to see the trend, and visualize the top variable genes. These genes are often marker genes that are uniquely expressed in specifi cell populations. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_genes <- as.data.frame(dec[top[1:10], ])\ntop_genes$genes <- rownames(top_genes)\n\nggplot(as.data.frame(dec), aes(mean, total)) +\n  geom_point() +\n  geom_text(\n    data = top_genes,\n    aes(label = genes)\n  ) +\n  stat_function(fun = function(x) metadata(dec)$trend(x))\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\nHow many variable genes to use? Depends on the data, generally use more variable genes with more complex and heterogeneous data. 1,000 - 2,000 is a reasonable starting point.\nExplore the impact of changing the getTopHVGs() arguments `n` or `prop` on the PCA, UMAP, and clustering. \n\n## PCA\n\nWe next perform PCA, but only on the normalized data from the `top` variable genes. By default `runPCA` will return the top 50 PCs, this can be changed with the `ncomponents` argument. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(101010011) # runPCA uses a specialize form of PCA that has a random component\nsce <- runPCA(sce, subset_row = top)\n```\n:::\n\n\n\nWe can plot the PCA using `plotPCA()`. Here I've colored the PCA by the expression of the `CD3D` gene, a general marker of T-cells\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotPCA(sce, color_by = \"CD3D\")\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\nPCs beyond 1 and 2 show additional patterns in the data. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotPCA(sce, ncomponents = 4, colour_by = \"CD3D\")\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nThe amount of variation captured in each PC is a useful metric to examine. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercent.var <- attr(reducedDim(sce), \"percentVar\")\nplot(percent.var, log = \"y\", xlab = \"PC\", ylab = \"Variance explained (%)\", pch = 16)\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\nIn general the # of PCs to use for downstream steps depends on the complexity and heterogeneity in the data, as well as the biological question. For this analysis we will retain the top 30, but you should explore how the downstream steps are affected by including fewer or more PCs.  \n\n In practice picking fewer PCs will identify fewer subpopulations, and picking more PCs will find more subpopulations, at the expense of potentially increased noise and longer runtime.\n \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreducedDim(sce, \"PCA\")[1:4, 1:4] # the PCA is stored in the reducedDim() slot\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                         PC1       PC2       PC3        PC4\nGCTGCAGTCCGATCTC -17.7865879 -5.494428 -3.609731 -2.2119402\nACTATGGAGGTCCCTG  -0.0933944  7.195291  2.840164  0.0138008\nATTTCTGTCTCTATGT -17.8824692 -1.533912 -3.546737  0.5637093\nTATCTGTAGGTGATAT -16.7533963 -2.843034 -5.289824 -1.3747961\n```\n\n\n:::\n\n```{.r .cell-code}\n# we can subset the PCA to fewer dimensions, e.g. 30\nreducedDim(sce, \"PCA\") <- reducedDim(sce, \"PCA\")[, 1:30]\n```\n:::\n\n\n## Dimensionality reduction for visualization\n\n### PCA\n\nEarly single cell studies simply used PCA to visualize single cell data. This is a fine approach for simple datasets, but often there is much more information present in higher principal components as we saw above\n\n### UMAP\n\nThe UMAP algorithm is popular, as it does a good job of preserving local differences between cells (e.g. differences in T-cell subtypes), while balancing global differences (e.g. a Neuron will be far away from a T-cell). \n\nI usually don't make too many changes to the parameters for UMAP, but these can be customized. The `n_neighbors` and `min_dist` arguments can have a large impact of the density and spread of the visualization. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234323523)\nsce <- runUMAP(sce, dimred = \"PCA\") # adds another reducedDim()\nreducedDims(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of length 2\nnames(2): PCA UMAP\n```\n\n\n:::\n:::\n\n\n\n`plotUMAP` is the plotting function for UMAPs. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotUMAP(sce, colour_by = \"CD3D\")\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplotUMAP(sce, colour_by = \"CD79A\")\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-14-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234323523)\nsce <- runUMAP(sce, dimred = \"PCA\", n_neighbors = 100, min_dist = 0.5)\nplotUMAP(sce, colour_by = \"CD3D\")\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplotUMAP(sce, colour_by = \"CD79A\")\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n:::\n\n\n\nHopefully these plots have convinced you that 1) interpreting a UMAP should be done with caution as the density of and distance between points is somewhat arbitrary 2) There are many ways to represent data in 2 dimensions. Deciding what is best depends on what point you are trying to emphasize with the visualization. \n\nOften these visualizations are a convenient way to convey a lot information in a single plot but the actual UMAP coordinates are not very meaningful in a scientific sense. \n\n## Clustering single cell data\n\nThe PCA/UMAP plots above indicate that there are likely different cell types present in the data as we can see clusters. Next we will formally cluster the dataset to assign cells to clusters. \n\nGraph based clustering methods are commonly used for single cell data, because they can scale to millions of cells, produce reasonable assignments, and have tuneable parameters. \nWe can cluster the data using ... `clusterCells()` from scran. \n\n**Note that the clustering is performed on the PCA matrix not the 2D UMAP plot**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(10101010)\nclusters <- clusterCells(sce, use.dimred = \"PCA\")\ntable(clusters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclusters\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 \n 766  257  552  122  369  211  141 1409   52   74   55   63   44   47  103   97 \n  17   18   19 \n 163   24   16 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsce$clusters <- clusters\n```\n:::\n\n\n\nThe parameters of the clustering can be changed by changing the `NNGraphParam`. Here are the defaults:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bluster)\nset.seed(10101010)\nclusters <- clusterCells(sce,\n  use.dimred = \"PCA\",\n  BLUSPARAM = NNGraphParam(\n    k = 10,\n    type = \"rank\",\n    cluster.fun = \"walktrap\"\n  )\n)\ntable(clusters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclusters\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 \n 766  257  552  122  369  211  141 1409   52   74   55   63   44   47  103   97 \n  17   18   19 \n 163   24   16 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsce$clusters <- clusters\n\nplotUMAP(sce, colour_by = \"clusters\")\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\nGenerally increasing the # of neighbors will decrease the number of clusters and vice versa. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(12121212)\n\nclusters <- clusterCells(sce,\n  use.dimred = \"PCA\",\n  BLUSPARAM = NNGraphParam(\n    k = 100,\n    type = \"rank\",\n    cluster.fun = \"walktrap\"\n  )\n)\n\nsce$coarse_clusters <- clusters\n\nplotUMAP(sce, colour_by = \"coarse_clusters\")\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\nWhat clusters are the genes S100A8, CD79A and CD3G most highly expressed in? We can use the `plotExpression()` function to visualize the expression data in each cluster.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotExpression(sce, features = c(\"S100A8\", \"CD79A\", \"CD3G\"), x = \"clusters\")\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n## How many clusters?\n\nClustering algorithms produce clusters, even if there isn’t anything meaningfully different between cells. Determining the optimal number of clusters can be tricky and also dependent on the biological question.\n\nSome guidelines:\n\n1) Cluster the data into a small number of clusters to identify cell types, then recluster to generate additional clusters to define sub-populations of cell types.\n\n2) To determine if the data is overclustered examine differentially expressed genes between clusters. If the clusters have few or no differentially expressed genes then the data is likely overclustered. Similar clusters can be merged post-hoc if necessary as sometimes it is difficult to use 1 clustering approach for many diverse cell populations. Using a reference-based approach to name cell types will also often merge similar clusters.\n\n3) A hybrid approach is to first annotate major cell types using a small # of clusters (e.g. B-cell, T-cell, Myeloid, etc.), then subset the SingleCellExperiment object for each cluster and perform additional clustering to obtain 'subclusters' (e.g. b-cell-subset 1, b-cell-subset 2, t-cell-subset-1, etc.)\n\n# Finding marker genes for each cluster\n\nMarker genes are genes that are specifically expressed in a cell type. We can identify these genes by performing differential expression analysis between clusters. We will use `scoreMarkers()` which will:\n\n- Compare many metrics for each gene between a pair of clusters\n\n- Perform these pairwise comparisons between every pair of clusters in the data\n\n- Summarize the metrics across all pairwise comparisons into a data frame, 1 for each cluster\n\nThe approach implemented by scoreMarkers() does **not** return any p-values for reasons described [here](https://bioconductor.org/books/3.17/OSCA.advanced/marker-detection-redux.html#p-value-invalidity). Statistical testing is invalidated because we clustered the data into groups based on the data itself, rather than by using an a priori group assignment. When we perform statistical testing on this group we are essentially testing the data again, which greatly inflates the significance of the pvalues. \n\n`scoreMarkers()` will return a list of DataFrames, one for each cluster tested.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmrks <- scoreMarkers(sce, sce$clusters)\nmrks\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of length 19\nnames(19): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\n```\n\n\n:::\n:::\n\n\n\n\nTo identify marker genes we will need to decide of cutoffs based on effect sizes. There are many reported by scoreMarkers(). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(mrks[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"self.average\"          \"other.average\"         \"self.detected\"        \n [4] \"other.detected\"        \"mean.logFC.cohen\"      \"min.logFC.cohen\"      \n [7] \"median.logFC.cohen\"    \"max.logFC.cohen\"       \"rank.logFC.cohen\"     \n[10] \"mean.AUC\"              \"min.AUC\"               \"median.AUC\"           \n[13] \"max.AUC\"               \"rank.AUC\"              \"mean.logFC.detected\"  \n[16] \"min.logFC.detected\"    \"median.logFC.detected\" \"max.logFC.detected\"   \n[19] \"rank.logFC.detected\"  \n```\n\n\n:::\n:::\n\n\nWhy are there so many columns of data and how does one decide what is a marker gene?\n\nThe problem is how do we define a marker gene. Is a marker gene a gene that is differentially expressed between 1 cluster and all other clusters? That could be too strict depending on the data, and could miss important gene expression differences between subtypes of cells. \n\nPerhaps a marker gene should be differentially expressed between some, or at the extreme any of the clusters.\n\nThe output of scoreMarkers() allows you to filter the data in many different ways depending on what type of marker you want to identify. Importantly it doesn't hide the complexity of this data. I highly recommend reading the chapter on [marker gene detection](https://bioconductor.org/books/3.17/OSCA.basic/marker-detection.html#motivation-2) from the OSCA book to understand how best to identify markers depending on the dataset you are analyzing. \n\nWe will use the `AUC` effect to rank markers. The AUC represents the probability that a randomly chosen observation from our cluster of interest is greater than a randomly chosen observation from the other cluster. A value of 1 means that the gene is upregulated in the cluster of interest and a value of 0 means that the gene is downregulated. 0.5 indicates no difference.\n\nOne can also rank on standardized log fold changes or the fold change in the detection rate. \n\nWe can either choose the `mean`, `min`, `median`, `max`, or `rank` AUC as a potential ranking, which all will select for marker genes with different patterns:\n\nParaphrasing from the OSCA book:\n\n- The most obvious summary statistic is the mean. For cluster X, a large mean effect size (>0.5 for the AUCs) indicates that the gene is upregulated in X compared to the average of the other groups.\n  \n- Another summary statistic is the median, where a large value indicates that the gene is upregulated in  X compared to most (>50%) other clusters. \n\n- The minimum value (min.*) is the most stringent summary for identifying upregulated genes, as a large value indicates that the gene is upregulated in X compared to all other clusters. \n  \n- The maximum value (max.*) is the least stringent summary for identifying upregulated genes, as a large value can be obtained if there is strong upregulation in X compared to any other cluster. \n\n- The minimum rank, a.k.a., “min-rank” (rank.*) is the smallest rank of each gene across all pairwise comparisons. Specifically, genes are ranked within each pairwise comparison based on decreasing effect size, and then the smallest rank across all comparisons is reported for each gene. If a gene has a small min-rank, we can conclude that it is one of the top upregulated genes in at least one comparison of  X to another cluster.\n\nHere we will plot top genes ranked by `mean.AUC` for cluster 1. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster1_markers <- as.data.frame(mrks[[1]]) |> tibble::rownames_to_column(\"gene\")\n\nordered <- cluster1_markers |>\n  dplyr::filter(mean.AUC > 0.5) |>\n  dplyr::arrange(desc(mean.AUC))\n\nplotExpression(sce,\n  features = head(ordered$gene),\n  x = \"clusters\",\n  colour_by = \"clusters\"\n)\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\nNext we will extract the top N markers from each cluster, ranked on `mean.AUC`, then plot the average expression of these markers in each cluster as a heatmap.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_top_markers <- 5\n\ntop_markers <- purrr::map_dfr(mrks, ~ {\n  .x |>\n    as.data.frame() |>\n    tibble::rownames_to_column(\"gene\") |>\n    dplyr::filter(mean.AUC > 0.5) |>\n    dplyr::arrange(desc(mean.AUC)) |>\n    dplyr::slice(1:n_top_markers)\n}, .id = \"cluster\")\n\ntop_markers[1:10, 1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   cluster      gene\n1        1    S100A9\n2        1    S100A8\n3        1       LYZ\n4        1      MNDA\n5        1      FCN1\n6        2     BANK1\n7        2     CD79A\n8        2     MS4A1\n9        2 TNFRSF13C\n10       2   RALGPS2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotGroupedHeatmap(sce,\n  features = unique(top_markers$gene),\n  group = \"clusters\",\n  center = TRUE,\n  zlim = c(-3, 3)\n)\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-26-1.png){width=864}\n:::\n:::\n\n\n\n# So how do we annotate each cluster as a cell type?\n\nIn the early days of single cell sequencing, this was often done manually, by visual inspection of key genes (hopefully) using expertise in the lab.  As more single cell datasets have become available, it is more common to compare your data to other single cell data or to reference cell type expression profiles.\n\nWe we use [`clustifyr`](https://rnabioco.github.io/clustifyr/) which was developed by a previous RBI fellow Rui Fu. There are also many other methods (e.g. `SingleR`)\n\n`clustifyr` works by comparing the average gene expression in each cluster to a reference matrix that contains average gene signatures of reference cell types. The reference can be built from other single cell data, bulk-rna-seq, or other sources. Ranked spearman correlation is used to compare the reference to the clusters. Only the variable genes are used for the correlation. \n\nIn order to compare our dataset we need to use a publicly available reference dataset. Thankfully many datasets have been organized into a separate package: [clustifyrdatahub](https://github.com/rnabioco/clustifyrdatahub). This is an extension of the `ExperimentHub` package on bioconductor that allows you to easily download and cache external datasets. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(clustifyr)\nlibrary(clustifyrdatahub)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ExperimentHub\n```\n\n\n:::\n\n```{.r .cell-code}\n# get reference dataset derived from a microarray experiment of sorted immune cell types\nref_hema_microarray()[1:5, 1:5]\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nsee ?clustifyrdatahub and browseVignettes('clustifyrdatahub') for documentation\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nloading from cache\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Basophils CD4+ Central Memory CD4+ Effector Memory CD8+ Central Memory\nDDR1    6.084244            5.967502             5.933039            6.005278\nRFC2    6.280044            6.028615             6.047005            5.992979\nHSPA6   6.535444            5.811475             5.746326            5.928349\nPAX8    6.669153            5.896401             6.118577            6.270870\nGUCA1A  5.239230            5.232116             5.206960            5.227415\n       CD8+ Effector Memory\nDDR1               5.895926\nRFC2               5.942426\nHSPA6              5.942670\nPAX8               6.323922\nGUCA1A             5.090882\n```\n\n\n:::\n:::\n\n\n\nBut you can download any dataset that characterizes cell populations that interest you.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- clustify(\n  sce, # SingleCellExperiment object\n  ref_mat = ref_hema_microarray(), # cell type reference data\n  cluster_col = \"clusters\", # column in metadata with clusters\n  # don't add to SingleCellExperiment object, just return results\n  obj_out = FALSE,\n  # use variable genes for comparison\n  query_genes = top,\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nobject data retrieval complete, moving to similarity computation\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nsee ?clustifyrdatahub and browseVignettes('clustifyrdatahub') for documentation\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nloading from cache\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nusing # of genes: 1075\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nsimilarity computation completed, matrix of 19 x 38, preparing output\n```\n\n\n:::\n\n```{.r .cell-code}\nres[1:12, 1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Basophils CD4+ Central Memory CD4+ Effector Memory CD8+ Central Memory\n1  0.5370093           0.4111325            0.4176017           0.3936302\n10 0.5945973           0.4591039            0.4655590           0.4433302\n11 0.4386922           0.7151960            0.7115503           0.6798845\n12 0.6333579           0.5402749            0.5289964           0.5160502\n13 0.3935435           0.6535071            0.6516310           0.6321161\n14 0.4656631           0.6099487            0.6324938           0.6493463\n15 0.6258199           0.5493260            0.5378138           0.5284327\n16 0.4883762           0.7668150            0.7549072           0.7346618\n17 0.6277840           0.5580115            0.5459105           0.5343926\n18 0.5650205           0.5267830            0.5237343           0.5021841\n19 0.3379409           0.3154402            0.3177152           0.3003928\n2  0.6210041           0.5744730            0.5678439           0.5518513\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ComplexHeatmap)\nHeatmap(t(res))\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-29-1.png){width=864}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncor_to_call(res) # assign cluster to highest correlation cell type (above a threshold). Cell types lower than a threshold will be assigned as unassigned.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 19 × 3\n# Groups:   cluster [19]\n   cluster type                                r\n   <chr>   <chr>                           <dbl>\n 1 11      CD4+ Central Memory             0.715\n 2 13      CD4+ Central Memory             0.654\n 3 5       CD4+ Effector Memory            0.769\n 4 3       CD8+ Effector Memory            0.747\n 5 2       Mature B-cell class switched    0.772\n 6 14      Mature NK cell_CD56- CD16- CD3- 0.715\n 7 6       Mature NK cell_CD56+ CD16+ CD3- 0.729\n 8 7       Mature NK cell_CD56+ CD16+ CD3- 0.735\n 9 19      Megakaryocyte                   0.462\n10 1       Monocyte                        0.756\n11 4       Monocyte                        0.713\n12 10      Myeloid Dendritic Cell          0.743\n13 9       Myeloid Dendritic Cell          0.641\n14 12      Naïve B-cells                   0.778\n15 15      Naïve B-cells                   0.794\n16 17      Naïve B-cells                   0.797\n17 16      Naive CD4+ T-cell               0.781\n18 8       Naive CD4+ T-cell               0.765\n19 18      Plasmacytoid Dendritic Cell     0.673\n```\n\n\n:::\n:::\n\n\n\nWe can insert the classification results into the SingleCellExperiment object directly which will be called `type`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\nsce <- clustify(\n  sce, # seurat object\n  ref_mat = ref_hema_microarray(), # cell type reference data\n  cluster_col = \"clusters\", # column in metadata with clusters\n  obj_out = TRUE,\n  # use variable genes for comparison\n  query_genes = top\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nobject data retrieval complete, moving to similarity computation\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nsee ?clustifyrdatahub and browseVignettes('clustifyrdatahub') for documentation\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nloading from cache\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nusing # of genes: 1075\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nsimilarity computation completed, matrix of 19 x 38, preparing output\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nusing threshold of 0.6\n```\n\n\n:::\n\n```{.r .cell-code}\nplotUMAP(sce, colour_by = \"type\")\n```\n\n::: {.cell-output-display}\n![](ex-32_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n\n# Saving your data and distributing datasets\n\n1) You can share your SingleCellExperiment objects with collaborators by saving the object as an `.rds` file. \n\n2) If you plan on publishing the data, then the best practices are to upload the UMI count matrix and your colData() data.frame containing the cell type annotations. \n\nTo save the UMI count matrix use write10xcounts() from the DropletUtils Bioconductor package.\n\n``` r\nmat <- counts(sce) \nwrite10xCounts(\"path/to/output\", mat)\n``` \n\nWhen saving the `colData()` it is also a nice gesture to include the UMAP coordinates that you used for the main visualizations in your manuscript. The clustering and UMAP coordinates are very hard to reproduce because of the non-deterministic elements of the algorithms. \n\n``` r\ncbind(colData(sce), reducedDim(sce, \"UMAP\")) |> \n  rownames_to_column(\"cell\") |> ()\n  write_csv(\"cell-level-metadata.csv\")\n```  \n",
    "supporting": [
      "ex-32_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"../site_libs/viz-1.8.2/viz.js\"></script>\n<link href=\"../site_libs/DiagrammeR-styles-0.2/styles.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/grViz-binding-1.0.11/grViz.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}