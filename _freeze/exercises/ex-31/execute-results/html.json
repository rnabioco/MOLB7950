{
  "hash": "5c53077b4d5cc4e458e44a6520e12ea0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Single cell RNA-seq class I\"\nauthor: \"Kent Riemondy\"\n---\n\n::: {.cell}\n\n:::\n\n\n\n# Overview\n\nToday we will begin a two-course segment on single cell RNA-seq analysis. We will begin with an introduction to single cell RNA-seq data, followed by a discussion of key quality control metrics used to exclude low-quality cells from the data. \n\n### Analyzing single cell data in R\n\nDroplet based scRNA-seq will produce libraries with 100,000 - 1,000,000 cell barcodes in each experiment, despite only 1-10,000 cells being loaded. Many of these barcodes are generated by non-cell containing empty droplets, which will end up with a few reads.\n\nStoring a matrix of 20,000 genes x 1,000,000 cell barcodes would require a large amount of memory (20 billion values). However most of these values (> 95%) are zeros due to many empty barcodes with few UMIs and the low efficiency of single cell library generation (< 10-20% efficient). To limit unnecessary memory usage single cell data matrices are stored in a `sparseMatrix` format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# typical dense matrix format\nvals <- c(\n  0, 0, 0, 2, 0,\n  0, 1, 0, 0, 0,\n  0, 0, 0, 0, 0,\n  0, 0, 0, 0, 1,\n  0, 0, 0, 0, 0\n)\n\nm <- matrix(vals, nrow = 5)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    0    0    0\n[4,]    2    0    0    0    0\n[5,]    0    0    0    1    0\n```\n\n\n:::\n:::\n\n\n\nConverting a dense matrix to a sparse matrix can be accomplished using the generic `as` function (which is a common way to convert formats). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsm <- as(m, \"sparseMatrix\")\n# alternatively\n# Matrix(vals, nrow = 5)\nsm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5 x 5 sparse Matrix of class \"dtCMatrix\"\n              \n[1,] . . . . .\n[2,] . 1 . . .\n[3,] . . . . .\n[4,] 2 . . . .\n[5,] . . . 1 .\n```\n\n\n:::\n:::\n\n\n\nThe sparse matrix format only stores non-zero values in the matrix. Internally , and in text formats, these are stored as a row column value triplet. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(sm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5 x 5 sparse Matrix of class \"dtCMatrix\", with 3 entries\n  i j x\n1 4 1 2\n2 2 2 1\n3 5 4 1\n```\n\n\n:::\n:::\n\n\n\nMany of the functions that manipulate matrices (e.g. `rowMeans`, `colSums`, `apply`, `[`) can also be used on sparseMatrices, provided that you load the `Matrix` package (e.g `library(Matrix)`).\n\n\nHow can we extract the first 2 rows and first 3 columns of the sparse matrix `sm` that we generated above?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# print subset of sm\nsm[1:2, 1:3]\n```\n:::\n\n\n\nHow can we calculate the sum of the columns of `sm`?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# find column sums of sparse\ncolSums(sm)\n```\n:::\n\n\n\n### Base R subsetting\n\nTo work with single cell data it will be helpful to know some base R concepts in such as\nsubsetting with brackets `[` and referencing and generating columns with `$`.\n\nVectors in R can be subset by vector index (position), a logical vector (c(TRUE, FALSE)), or name (if the vector is named). \n\nConsider the following character vector `letters`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# extract 2nd, 4th, and 6th entry\nletters[c(2, 4, 6)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"b\" \"d\" \"f\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# subset by creating logical vector\nvowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\")\nis_a_vowel <- letters %in% vowels\n\nletters[is_a_vowel]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"e\" \"i\" \"o\" \"u\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# name the letters vector with uppercase LETTERS\nnames(letters) <- LETTERS\n\n# subset by name\nletters[c(\"A\", \"Z\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  A   Z \n\"a\" \"z\" \n```\n\n\n:::\n:::\n\n\n\nMatrices are 2 dimensional vectors and have similar subsetting rules except there are two dimensions, rows and columns.\n\n`matrix[rows_to_subset, columns_to_subset]`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:24, nrow = 6)\n\n# extract 2nd, 4th, and 6th row\nm[c(2, 4, 6), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    8   14   20\n[2,]    4   10   16   22\n[3,]    6   12   18   24\n```\n\n\n:::\n\n```{.r .cell-code}\n# extract 2nd and 4th column\nm[, c(2, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    7   19\n[2,]    8   20\n[3,]    9   21\n[4,]   10   22\n[5,]   11   23\n[6,]   12   24\n```\n\n\n:::\n\n```{.r .cell-code}\n# first 3 rows and 2nd and 4th column\nm[1:3, c(2, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    7   19\n[2,]    8   20\n[3,]    9   21\n```\n\n\n:::\n\n```{.r .cell-code}\n# extract rows with totals > 50\nm[rowSums(m) > 50, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    4   10   16   22\n[2,]    5   11   17   23\n[3,]    6   12   18   24\n```\n\n\n:::\n\n```{.r .cell-code}\n# extract columns with minimum values < 8\nm[, colMins(m) < 8]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    7\n[2,]    2    8\n[3,]    3    9\n[4,]    4   10\n[5,]    5   11\n[6,]    6   12\n```\n\n\n:::\n:::\n\n\n\nThe base R `data.frame` and Bioconductor `DataFrame` can also be subset with the `[` and we can reference individual vectors in a data.frame using `$`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first 3 rows and columns of mtcars data.frame\nmtcars[1:3, 1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               mpg cyl disp\nMazda RX4     21.0   6  160\nMazda RX4 Wag 21.0   6  160\nDatsun 710    22.8   4  108\n```\n\n\n:::\n\n```{.r .cell-code}\n# columns can be referenced using $, which extracts a vector\nmtcars$mpg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n```\n\n\n:::\n\n```{.r .cell-code}\n# columns can be generated or overwritten using $ with assignment\nmtcars$new_column_name <- \"Hello!\"\nmtcars$wt <- mtcars$wt * 1000\n\n# We can subset using logical vectors\n# E.g. filter for rows (cars) with mpg > 20\nmtcars[mtcars$mpg > 20, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                mpg cyl  disp  hp drat   wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3215 19.44  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2780 18.60  1  1    4    2\n               new_column_name\nMazda RX4               Hello!\nMazda RX4 Wag           Hello!\nDatsun 710              Hello!\nHornet 4 Drive          Hello!\nMerc 240D               Hello!\nMerc 230                Hello!\nFiat 128                Hello!\nHonda Civic             Hello!\nToyota Corolla          Hello!\nToyota Corona           Hello!\nFiat X1-9               Hello!\nPorsche 914-2           Hello!\nLotus Europa            Hello!\nVolvo 142E              Hello!\n```\n\n\n:::\n:::\n\n\n\n\n### Reading alevin output into R with tximport\n\nOur old-friend, the `tximport` package, has methods for importing the binary data from alevin. We need to supply a path to the `quants_mat.gz` file. Note that in contrast to importing data from salmon, tximport only allows 1 file to be loaded. If you want to load multiple samples use iteration approaches (e.g. `lapply`, `purrr::map`, a `for` loop). Also note that the [`eds`](https://bioconductor.org/packages/release/bioc/html/eds.html) package was installed which greatly speeds up the loading of the matrix.\n\nWe will load in data from a 10x Genomics scRNA-seq library generated from human periperhal blood mononuclear cells (PMBCS). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tximport)\ntx <- tximport(\n  here(\"data/block-rna/scrna/pbmc/alevin/quants_mat.gz\"),\n  type = \"alevin\"\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nreading in alevin gene-level counts across cells with 'eds'\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(tx)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"abundance\"           \"counts\"              \"countsFromAbundance\"\n```\n\n\n:::\n:::\n\n\n\n`tx` is a list with 3 elements, `abundance`, `counts`, and `countsFromAbundance`. Let's look at the counts element\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- tx$counts\nmat[5:10, 1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6 x 3 sparse Matrix of class \"dgCMatrix\"\n                GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ATTTCTGTCTCTATGT\nENSG00000243485                .                .                .\nENSG00000284332                .                .                .\nENSG00000237613                .                .                .\nENSG00000268020                .                .                .\nENSG00000290826                .                .                .\nENSG00000240361                .                .                .\n```\n\n\n:::\n:::\n\n\n\nHere you can see that `tx$counts` is a sparse matrix that is genes (rows) by cells (columns).\n\nHow many barcodes are in `tx$counts`? How many genes?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# TODO Find number of barcodes and genes in tx$counts\ndim(mat)\n```\n:::\n\n\n\nWhat fraction of the matrix is non-zero? We can use the `nnzero `function from the `Matrix` package check\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnnzero(mat) / length(mat) # (length = # of rows X # of columns)\n# similarily\nsum(mat > 0) / length(mat)\n```\n:::\n\n\n\n## The SingleCellExperiment class\n\nSingle cell analysis is centered around the `SingleCellExperiment` data structure, which serves as a single container to store the input data, various transformations (count data, normalized count data, PCA, UMAPs, etc.) and any results that are generated.\n\n![](../img/block-rna/sce.png)\n\n### Creating a SingleCellExperiment object\n\n A `SingleCellExperiment` object can be created from our sparse matrix using the `SingleCellExperiment()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- SingleCellExperiment(list(counts = mat))\nsce\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: SingleCellExperiment \ndim: 62266 6075 \nmetadata(0):\nassays(1): counts\nrownames(62266): ENSG00000290825 ENSG00000223972 ... ENSG00000210195\n  ENSG00000210196\nrowData names(0):\ncolnames(6075): GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ... ACGTAGGGTGACAGCA\n  TCTCAGCTCGCCGAAC\ncolData names(0):\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n\n\nThe `SingleCellExperiment` object stores the gene x cell count matrix within `assays()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get list of assays\nassays(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of length 1\nnames(1): counts\n```\n\n\n:::\n\n```{.r .cell-code}\n# extract single assay\nassay(sce, \"counts\")[1:4, 1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4 x 4 sparse Matrix of class \"dgCMatrix\"\n                GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ATTTCTGTCTCTATGT\nENSG00000290825                .                .                .\nENSG00000223972                .                .                .\nENSG00000227232                .                .                .\nENSG00000278267                .                .                .\n                TATCTGTAGGTGATAT\nENSG00000290825                .\nENSG00000223972                .\nENSG00000227232                .\nENSG00000278267                .\n```\n\n\n:::\n\n```{.r .cell-code}\nassays(sce)$counts[1:4, 1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4 x 4 sparse Matrix of class \"dgCMatrix\"\n                GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ATTTCTGTCTCTATGT\nENSG00000290825                .                .                .\nENSG00000223972                .                .                .\nENSG00000227232                .                .                .\nENSG00000278267                .                .                .\n                TATCTGTAGGTGATAT\nENSG00000290825                .\nENSG00000223972                .\nENSG00000227232                .\nENSG00000278267                .\n```\n\n\n:::\n\n```{.r .cell-code}\n# convenience function for counts assay\ncounts(sce)[1:4, 1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4 x 4 sparse Matrix of class \"dgCMatrix\"\n                GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ATTTCTGTCTCTATGT\nENSG00000290825                .                .                .\nENSG00000223972                .                .                .\nENSG00000227232                .                .                .\nENSG00000278267                .                .                .\n                TATCTGTAGGTGATAT\nENSG00000290825                .\nENSG00000223972                .\nENSG00000227232                .\nENSG00000278267                .\n```\n\n\n:::\n:::\n\n\n\n## Accessing and storing cell and gene level metadata\n\nAs we perform analyses we will accumulate cell-level information, such as quality control metrics, clustering results, and celltype assignments. \nThe SingleCellExperiment class stores this data within a data frame called `colData`, which we can access using `colData()`. This is a specialized Bioconductor specific data.frame class (`DataFrame`) which has similar semantics and functionality to a base R data.frame. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# empty right now.\ncolData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 6075 rows and 0 columns\n```\n\n\n:::\n\n```{.r .cell-code}\n# add a sample annotation\ncolData(sce)$cell_source <- \"PBMC\"\n\n# equivalent approach using $\nsce$cell_source <- \"PBMC\"\n\ncolData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 6075 rows and 1 column\n                 cell_source\n                 <character>\nGCTGCAGTCCGATCTC        PBMC\nACTATGGAGGTCCCTG        PBMC\nATTTCTGTCTCTATGT        PBMC\nTATCTGTAGGTGATAT        PBMC\nAGCCAGCCAAAGCACG        PBMC\n...                      ...\nCATCCCAAGTACTCGT        PBMC\nCTCCTCCCATGAAGCG        PBMC\nAGTTCCCCATGTCAGT        PBMC\nACGTAGGGTGACAGCA        PBMC\nTCTCAGCTCGCCGAAC        PBMC\n```\n\n\n:::\n:::\n\n\n\nThe SingleCellExperiment also stores gene-level metadata in a data.frame called `rowData()`. We will use the rowData to store gene ids, symbols, and other information about genes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# empty right now\nrowData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 62266 rows and 0 columns\n```\n\n\n:::\n:::\n\n\n\n# Manipulating and subsetting a SingleCellExperiment\n\nTo get familiar with SingleCellExperiment objects let's *calculate the total number of counts in each cell and store these counts in the `colData().*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce$total_counts <- colSums(counts(sce))\n```\n:::\n\n\n\nNext let's calculate *the total number of counts for each gene, summed across cells* and *the number of cells with > 0 counts per gene*, and store both of these values in the rowData(). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowData(sce)$total_gene_counts <- rowSums(counts(sce))\nrowData(sce)$n_cells_expr <- rowSums(counts(sce) > 0)\nrowData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 62266 rows and 2 columns\n                total_gene_counts n_cells_expr\n                        <numeric>    <integer>\nENSG00000290825         65.594607           43\nENSG00000223972          0.000000            0\nENSG00000227232          5.506349           24\nENSG00000278267          0.000000            0\nENSG00000243485          0.333333            1\n...                           ...          ...\nENSG00000198695              2054         1509\nENSG00000210194                 0            0\nENSG00000198727            274421         5704\nENSG00000210195                 0            0\nENSG00000210196                 0            0\n```\n\n\n:::\n:::\n\n\n\nWe can subset the SingleCellExperiment using the same syntax used to subset base R data.frames and matrices. Note that `dplyr` verbs do not work with `SingleCellExperiment` (see alternative [tidySingleCellExperiment](https://bioconductor.org/packages/release/bioc/html/tidySingleCellExperiment.html)).\n\n```r\ndata.frame[rows, columns]\n\nsce[genes, cells]\n```\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# subset to data from first 4 genes and cells\nsce[1:4, 1:4]\n\n# subset to cells from PBMC cells\nsce[, sce$cell_source == \"PBMC\"]\n\n\ngenes_to_keep <- c(\"ENSG00000223972\", \"ENSG00000210195\", \"ENSG00000210196\")\nsce[genes_to_keep, ]\n\ncells_to_keep <- c(\"ACTATGGAGGTCCCTG\", \"GCTGCAGTCCGATCTC\", \"TCTCAGCTCGCCGAAC\")\nsce[, cells_to_keep]\n```\n:::\n\n\n\n\nMany additional functions used on data.frames also work on SingleCellExperiment:\n\n`ncol()`: # of cells  \n`nrow()`: # of gene  \n`dims()`: # of genes and cells  \n`rownames()`: rownames in matrices (e.g. genes)  \n`colnames()`: colnames in matrices (e.g. cells)   \n`cbind()`: combine multiple SingleCellExperiments by column  \n`rbind()`: combine multiple SingleCellExperiments by row  \n\n# Storing gene identifier information\n\nYou'll notice that our matrix has ensembl gene ids as the rownames (e.g. ENSG00000289576, ENSG00000221539). This is intentional as these identifiers are guaranteed to be unique and are a more stable and reliable identifier than gene symbols (e.g. ACTB, GAPDH). This becomes important if you want to compare to external datasets or ensure that your data can be easily used by others in the future.\n\nThese identifiers are useful but not as easy to interpret as gene symbols. Next we will retrieve gene symbols from an `AnnotationHub()` ensembldb resource and store the identifiers in the rowData().\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nah <- AnnotationHub()\n# download ensembl database\nens_db <- ah[[\"AH113665\"]]\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nloading from cache\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrequire(\"ensembldb\")\n```\n\n\n:::\n\n```{.r .cell-code}\ngene_names <- mapIds(ens_db,\n  keys = rownames(sce),\n  keytype = \"GENEID\",\n  column = \"SYMBOL\"\n)\n\nrowData(sce)$gene <- gene_names\nrowData(sce)$gene_id <- rownames(sce)\nrowData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 62266 rows and 4 columns\n                total_gene_counts n_cells_expr        gene         gene_id\n                        <numeric>    <integer> <character>     <character>\nENSG00000290825         65.594607           43     DDX11L2 ENSG00000290825\nENSG00000223972          0.000000            0     DDX11L1 ENSG00000223972\nENSG00000227232          5.506349           24      WASH7P ENSG00000227232\nENSG00000278267          0.000000            0   MIR6859-1 ENSG00000278267\nENSG00000243485          0.333333            1 MIR1302-2HG ENSG00000243485\n...                           ...          ...         ...             ...\nENSG00000198695              2054         1509      MT-ND6 ENSG00000198695\nENSG00000210194                 0            0       MT-TE ENSG00000210194\nENSG00000198727            274421         5704      MT-CYB ENSG00000198727\nENSG00000210195                 0            0       MT-TT ENSG00000210195\nENSG00000210196                 0            0       MT-TP ENSG00000210196\n```\n\n\n:::\n:::\n\n\n\nWe'd like to set the rownames of the object to symbols, but some of these are ` `, `NA` or duplicated which will cause problems. `uniquifyFeatureNames()` is a convenience function that will rename gene symbols that are `NA` or duplicated values to the ensembl ID or a combination of gene symbol and ensembl ID.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(sce) <- uniquifyFeatureNames(\n  rowData(sce)$gene_id,\n  rowData(sce)$gene\n)\nhead(rownames(sce))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"DDX11L2_ENSG00000290825\" \"DDX11L1\"                \n[3] \"WASH7P\"                  \"MIR6859-1\"              \n[5] \"MIR1302-2HG\"             \"MIR1302-2\"              \n```\n\n\n:::\n:::\n\n\n\n## Quality control and cell filtering  \n\nNow that we have our data in a SingleCellExperiment we will perform some filtering and quality control to remove low expression genes and poor quality cells.\n \nOur SingleCellExperiment has 62266 genes in the matrix. Most of these are\nnot expressed. We want to exclude these genes as they won't provide any useful\ndata for the analysis. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# exclude genes expressed in fewer than 10 cells (~ 1% of cells)\nrowData(sce)$n_cells <- rowSums(counts(sce) > 0)\nsce <- sce[rowData(sce)$n_cells >= 10, ]\nsce\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: SingleCellExperiment \ndim: 20858 6075 \nmetadata(0):\nassays(1): counts\nrownames(20858): DDX11L2_ENSG00000290825 WASH7P ... MT-ND6 MT-CYB\nrowData names(5): total_gene_counts n_cells_expr gene gene_id n_cells\ncolnames(6075): GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ... ACGTAGGGTGACAGCA\n  TCTCAGCTCGCCGAAC\ncolData names(2): cell_source total_counts\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n\n\nTo exclude low-quality cells we will use the following metrics:\n\n* Number of counts per cell barcode\n* Number of genes detected per barcode\n* The percentage of counts from mitochondrial genes per barcode\n\nA low number of counts, a low number of detected genes, and a high percentage of mitochondrial counts suggests that the cell had a broken membrane and the cytoplasmic mRNA leaked out. Conversely, an abnormally high number of counts and detected genes could indicate the presence of a doublet. See publication for more info ([Classification of low quality cells from single-cell RNA-seq data](https://doi.org/10.1186/s13059-016-0888-1))\n\nTo calculate these metrics we can use `addPerCellQCMetrics` from scater. Mitochondrial genes are named with a common \"MT-\" prefix (e.g. MT-CO2, MT-ATP6, MR-RNR2), which we can use to identify them.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# identify subset of genes that are from mitochondrial genome\nis_mito <- startsWith(rowData(sce)$gene, \"MT-\")\nsce <- addPerCellQCMetrics(sce, subsets = list(Mito = is_mito))\ncolData(sce)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 6075 rows and 8 columns\n                 cell_source total_counts       sum  detected subsets_Mito_sum\n                 <character>    <numeric> <numeric> <integer>        <numeric>\nGCTGCAGTCCGATCTC        PBMC        31924   31908.0      5718          2668.49\nACTATGGAGGTCCCTG        PBMC        35845   35801.5      6073          3963.23\nATTTCTGTCTCTATGT        PBMC        31788   31758.3      6377          2496.33\nTATCTGTAGGTGATAT        PBMC        32025   31998.0      6260          2961.15\nAGCCAGCCAAAGCACG        PBMC        29882   29856.0      5746          2660.44\n...                      ...          ...       ...       ...              ...\nCATCCCAAGTACTCGT        PBMC          151   151.000       132               12\nCTCCTCCCATGAAGCG        PBMC          133   132.500       131                6\nAGTTCCCCATGTCAGT        PBMC          173   172.667       166                8\nACGTAGGGTGACAGCA        PBMC          255   253.000       217               13\nTCTCAGCTCGCCGAAC        PBMC          144   144.000       149                4\n                 subsets_Mito_detected subsets_Mito_percent     total\n                             <integer>            <numeric> <numeric>\nGCTGCAGTCCGATCTC                    13              8.36307   31908.0\nACTATGGAGGTCCCTG                    15             11.07002   35801.5\nATTTCTGTCTCTATGT                    15              7.86038   31758.3\nTATCTGTAGGTGATAT                    15              9.25417   31998.0\nAGCCAGCCAAAGCACG                    15              8.91092   29856.0\n...                                ...                  ...       ...\nCATCCCAAGTACTCGT                     5              7.94702   151.000\nCTCCTCCCATGAAGCG                     5              4.52830   132.500\nAGTTCCCCATGTCAGT                     6              4.63320   172.667\nACGTAGGGTGACAGCA                     6              5.13834   253.000\nTCTCAGCTCGCCGAAC                     2              2.77778   144.000\n```\n\n\n:::\n:::\n\n\n\nWe can use the `plotColData()` function from scater to plot various metrics (as a ggplot2 object). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotColData(sce, y = \"sum\")\n```\n\n::: {.cell-output-display}\n![](ex-31_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotColData(sce, y = \"detected\")\n```\n\n::: {.cell-output-display}\n![](ex-31_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotColData(sce, y = \"detected\", x = \"sum\", colour_by = \"subsets_Mito_percent\")\n```\n\n::: {.cell-output-display}\n![](ex-31_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotColData(sce, y = \"subsets_Mito_percent\", x = \"sum\") +\n  labs(x = \"# of counts\")\n```\n\n::: {.cell-output-display}\n![](ex-31_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\nAlso note that you can easily extract the `colData()` as a data.frame to use with ggplot2 for custom plots. To extract additional features, e.g. per cell gene expression, you can use `makePerCellDF()` or `makePerFeatureDF()` from scater.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncell_info <- as.data.frame(colData(sce))\nggplot(cell_info, aes(sum, subsets_Mito_percent)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ex-31_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n\n\nSelecting an appropriate cutoff can be somewhat arbitrary, and there is a risk of excluding meaningful cell populations. I suggest starting with lenient cutoffs, then later increasing the stringency after examining the clustering and cell types.  \n\nLet's define high quality cell as those with less than 20% counts from mitocondrial RNAs, greater than 500 genes detected, and greater than 1000 total counts. *How many cells pass these criteria?*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npass_qc <- sce$subsets_Mito_percent < 20 & sce$detected > 500 & sce$sum > 1000\nsum(pass_qc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4565\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLabeling the qc failed cells in plots can be helpful. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce$pass_qc <- sce$subsets_Mito_percent < 20 & sce$detected > 500 & sce$sum > 1000\n\nplotColData(sce,\n  y = \"subsets_Mito_percent\",\n  x = \"sum\",\n  colour_by = \"pass_qc\"\n) +\n  labs(x = \"# of counts\")\n```\n\n::: {.cell-output-display}\n![](ex-31_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n\nLastly we can subset the `SingleCellExperiment` to exclude the low-quality cells. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- sce[, sce$pass_qc]\nsce\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: SingleCellExperiment \ndim: 20858 4565 \nmetadata(0):\nassays(1): counts\nrownames(20858): DDX11L2_ENSG00000290825 WASH7P ... MT-ND6 MT-CYB\nrowData names(5): total_gene_counts n_cells_expr gene gene_id n_cells\ncolnames(4565): GCTGCAGTCCGATCTC ACTATGGAGGTCCCTG ... CTGGATCCACCGTACG\n  TACAACGGTCTCGCGC\ncolData names(9): cell_source total_counts ... total pass_qc\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\n```\n\n\n:::\n:::\n\n\n\nIt is often a good idea to save the `SingleCellExperiment` at periodic steps in the analysis. Use `saveRDS()` to store the object as a file, which can later be imported back into R using `readRDS(). `\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(sce, \"path/to/a/file.rds\")\n```\n:::\n\n\n\n\n## Analysis steps revisited\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"grViz html-widget html-fill-item\" id=\"htmlwidget-120219a50996f13a7c7e\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-120219a50996f13a7c7e\">{\"x\":{\"diagram\":\"\\ndigraph workflow {\\n  graph [layout = dot,\\n         rankdir = TD]\\n\\n  node [shape = cicle,\\n        style = filled,\\n        fontcolor = black,\\n        fontname = \\\"Helvetica\\\"]\\n\\n  # green\\n  node [fillcolor = \\\"#009E73\\\"]\\n  load [label= \\\"Import data\\ntximport::tximport()\\nSingleCellExperiment()\\ncounts()\\\"]\\n\\n  # blue\\n  node [fillcolor = \\\"#56B4E9\\\"]\\n  cell_qc [label = \\\"QC cells\\n addPerCellQCMetrics()\\n plotColData()\\\"]\\n  norm [label = \\\"Normalize UMI counts\\nquickCluster()\\n computeSumFactors()\\n logNormCounts()\\\"]\\n\\n  # yellow\\n  node [fillcolor = \\\"#F0E442\\\"]\\n  feature [label = \\\"Identify variable genes\\nmodelGeneVarByPoisson()\\n getTopHVGs()\\\"]\\n  dim_red [label = \\\"Dimensionality reduction via PCA \\n runPCA()\\\"]\\n  cluster [label = \\\"Clustering\\n clusterCells()\\\"]\\n  viz [label = \\\"Make 2D-Visualization\\nrunUMAP()\\\"]\\n\\n  # blue\\n  node [fillcolor = \\\"#56B4E9\\\"]\\n\\n  markers [label = \\\"Discover cell type markers \\nscoreMarkers()\\\"]\\n  annot [label = \\\"Annotate cell types\\nclustifyr and SingleR\\\"]\\n\\n  edge [color = black\\n        fontname = \\\"Helvetica\\\"]\\n\\n  load -> cell_qc\\n  cell_qc -> norm\\n  norm -> feature\\n  norm -> markers\\n  feature -> dim_red\\n  dim_red -> cluster\\n  dim_red -> viz\\n  cluster -> markers\\n  markers -> annot\\n\\n  edge [color = \\\"grey\\\"\\n        style = \\\"dashed\\\"]\\n  annot -> cell_qc [label = \\\"Repeat\\n as needed\\\"]\\n  annot -> feature\\n  annot -> dim_red\\n  annot -> cluster\\n}\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n## Normalization\n\nNormalization attempts to correct for technical biases that will distort biological signal in the data. A large source of variation arises due to differences in sequencing depth between cells. This can be seen by performing PCA on the unnormalized counts. We will use `runPCA` from scater to perform PCA. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set seed for functions with a randomized component\n# to obtain the same result each execution\nset.seed(20231023)\nsce <- runPCA(sce, exprs_values = \"counts\", name = \"count_PCA\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotReducedDim(sce, \"count_PCA\", colour_by = \"sum\")\n```\n\n::: {.cell-output-display}\n![](ex-31_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\n\nNote that PC1 is correlated with the total UMI counts (`sum`), meaning that the largest source of variation is related to differences in sequencing depth rather than biological differences between cells. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_df <- makePerCellDF(sce, c(\"count_PCA\", \"sum\"))\n\nggplot(plot_df, aes(count_PCA.1, sum)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ex-31_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\n\nTo normalize we will use 3 functions from the scran package. The normalization entails crude clustering to group related cells, identifying a cell-specific normalization factor (size factor), then scaling the counts by this factor and log transforming the data (with a pseudocount). The algorithm is described in detail in the following paper and in the R documentation (`?scuttle::computePooledFactors`)\n\n>Lun AT, Bach K, Marioni JC. Pooling across cells to normalize single-cell RNA sequencing data with many zero counts. Genome Biol. 2016 Apr 27;17:75. doi: 10.1186/s13059-016-0947-7. PMID: 27122128; PMCID: PMC4848819.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(20231023)\nclusters <- quickCluster(sce)\nsce <- computeSumFactors(sce, clusters = clusters)\nsce <- logNormCounts(sce)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(20231023)\nsce <- runPCA(sce, exprs_values = \"logcounts\", name = \"PCA\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotReducedDim(sce, \"PCA\", colour_by = \"sum\")\n```\n\n::: {.cell-output-display}\n![](ex-31_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_df <- makePerCellDF(sce, c(\"PCA\", \"sum\"))\nggplot(plot_df, aes(PCA.1, sum)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ex-31_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\n\nWe can now see that PC1 does not correlate with total UMI counts and now shows some more distinct groups of cells, which will likely be different cell populations. \n\n",
    "supporting": [
      "ex-31_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"../site_libs/viz-1.8.2/viz.js\"></script>\n<link href=\"../site_libs/DiagrammeR-styles-0.2/styles.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/grViz-binding-1.0.11/grViz.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}