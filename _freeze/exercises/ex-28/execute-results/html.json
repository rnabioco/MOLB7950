{
  "hash": "3301d2d0deb7d05adae61defc15cf3bd",
  "result": {
    "markdown": "---\ntitle: \"RBP-RNA part 1\"\nauthor: \"Neelanjan Mukherjee\"\n---\n\n\n\n\n## Learning Objectives {.smaller}\n\n-   Describe the steps involved in performing CLIP-seq experiment to identify RBP binding sites transcriptome-wide.\n\n-   Understand how CLIP-seq data is processed from reads to generate binding sites.\n\n-   Assign the binding sites to genes and transcipt regions - 3' UTR, CDS, intron, etc.\n\n-   Determine the sequences bound by the RBP using proper background sequence models.\n\n## Background {.smaller}\n\n![](/img/block-rna/RNA_life_cycle.png)\n\nRNA-binding proteins (RBPs) interact with RNAs to control every regulatory step from transcription to translation.\n\nRBPs bind to specific regulatory elements with RNAs. These regulatory elements are specific sequence and/or structures recognized by the RBPs.\n\nFor example, an RBP might bind to specific sequences in the 3' UTR of an mRNA and recruit enzymes to promote deadenylation (removal of polyA tails) and subsequent target RNA decay.\n\n## Why do we need to know binding sites? {.smaller}\n\n![Genome browser shot of Ago1 CLIP-seq data for the Drosophila gene mbt 3' UTR.](/img/block-rna/motivation.jpg)\n\n-   RBPs and microRNAs recognize short sequences: 4-7 nucleotides.\n-   These sequences appear quite frequently (purple) in a 3' UTR.\n-   Conservation is often used to focus sites more likely to be functional/important.\n-   However, the binding evidence allows one to know the functional regulatory element.\n\n## Mapping of RBP binding sites: CLIP-seq {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n-   Covalent cross-linking of RBPs to RNA using 254 nm UV light.\n-   Lyse cells\n-   Mild digestion with RNase (leaving protein protected RNA fragments )\n-   Immunoprecipitate your RBP of interest (better have a good antibody)\n-   Ligate labeled 3' adapter RNA\n-   Cut out region corresponding to crosslinked RBP (and matched input)\n-   Proteinase K treat and isolate RNA\n-   Reverse transcription\n-   Make library from cDNA fragments and SEQUENCE!\n:::\n\n::: {.column width=\"50%\"}\n![](/img/block-rna/clipseq.jpg)\n:::\n:::\n\n## Mapping of RBP binding sites: PAR-CLIP {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n**PAR-CLIP**: photoactivatable ribonucleoside enhanced clip\n\n-   4-thiouridine (4sU) incorporation increases cross-linking efficiency\n-   Cross-linking \\~310 nm UV (blacklight)\n-   T -\\> C transitions provide nucleotide resolution binding\n-   During cDNA generation, preferential base pairing of the 4SU crosslink product to a guanine instead of an adenine results in a thymine (T) to cytosine (C) transition in the PCR-amplified sequence, serving as a diagnostic mutation at the site of contact.\n:::\n\n::: {.column width=\"50%\"}\n![](/img/block-rna/nihms832576f1.jpg){width=\"389\"}\n:::\n:::\n\n\n## Mapping of RBP binding sites: analysis {.smaller}\n\n::: columns\n::: {.column width=\"50%\" .nonincremental}\n\nMost CLIP-seq approaches have single-nucleotide resolution information. However, they vary in the frequency of that information and the efficiency of the procedure.\n\nThe basic concept to **call a peak/binding sites** from CLIP-seq:\n\n-   Map the reads to genome/transcriptome\n-   Group overlapping reads\n-   Use nucleotide level information to de/refine position of RBP-binding sites\n\nIn this class we will be working with PAR-CLIP data. Regardless, I will show you how to access ENCODE eCLIP data. You would easily be able to apply what you learn on those data.\n\n:::\n\n::: {.column width=\"50%\"}\n![](/img/block-rna/reads_cliptype.jpg)\n:::\n:::\n\n\n## Analysis overview {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n\n![](/img/block-rna/workflow.jpg)\n\n::: \n::: {.column width=\"50%\" .nonincremental}\n\n1. Filter out low quality or short reads (<18 for larger genomes)  \n2. Trim adapters  \n3. Collapse PCR duplicate reads (molecular indexes)  \n4. Align to genome/transcriptome  \n5. Call peaks\n6. Downstream analysis\n\n:::\n:::\n\n## Pre-processing {.smaller}\n\n[Cutadapt](https://cutadapt.readthedocs.io/en/stable/)\n\n\n\n![](/img/block-rna/adapters.jpg)\n\n\n## Calling binding sites: PARalyzer {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n\nThe pattern of T = > C conversions, coupled with read density, can thus provide a strong signal to generate a high-resolution map of confident RNA-protein interaction sites.\n\nA non-parametric kernel-density estimate used to identify the RNA-protein interaction sites from a combination of T = > C conversions and read density.\n\nSee [PARalyzer](https://pubmed.ncbi.nlm.nih.gov/21851591/) for more information.\n\n:::\n::: {.column width=\"50%\"}\n\n![](/img/block-rna/FMRreads.png)\n:::\n:::\n\n\n## Today's menu {.smaller}  \n\nWe will be starting with position of the binding sites in the genome (the output of PARalyzer) and we will:  \n\n#### 1a. Annotated the genes and regions of the binding sites.  \n\n#### 1b. Calculate a summary table for binding sites per gene per region.  \n\n#### 2. Perform motif analysis accounting for the background sequence regions.  \n \n\n![](/img/block-rna/workflow_2hallf.jpg)\n\n## Annotation of binding sites {.smaller}\n\n\nWhere are the binding sites?  \n- Which genes?  \n- What region of those genes?  \n- How many binding sites per region?  \n- How many binding sites per gene?  \n- How many binding sites per gene by region?  \n\nWe will use `annotatr` and `Granges` to answer these questions.\n\n![](/img/block-rna/annotation.jpeg)\n\n## Set up annotation database {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npossible_annotations <- builtin_annotations()\n\n# grep to keep those containing \"hg19\"\nhg19_annots <- grep(\n  \"??_genes\",\n  possible_annotations,\n  value = T)\n\n# WHY DID WE PICK hg19?\n\n# let's keep 5' utr, cds, intron, 3' utr and intergenic\nmy_hg19_annots <- hg19_annots[c(3,4,7,10,11)]\n\n# build the annotation database\nannotations <- build_annotations(\n  genome = 'hg19',\n  annotations = ??)\n\nannotations\n```\n:::\n\n\n\n\n## Extract annotation categories {.smaller}\n\nWhat information is contained within the `annotations` object?  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_hg19_annots[3]\n\n# get introns\nannotation_introns <- annotations[annotations$type == ??]\n\n# collapsing introns\nannotation_introns <- GenomicRanges::reduce(annotation_introns)\n\n# length of each intron interval\nlength_introns <- width(??)\n\n#get cds\nannotation_cds <- annotations[annotations$type == my_hg19_annots[1]]\n\n# collapsing cds\nannotation_cds <- GenomicRanges::reduce(annotation_cds)\n\n# length of each cds interval\nlength_cds <- width(annotation_cds)\n```\n:::\n\n\n\n\n\n\n## Compare introns and cds length {.smaller}\n\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nall_length <- bind_rows(\n  tibble(nt=??,\n       cat=rep(\"??\",\n               length(??))),\n  \n  tibble(nt=length_cds,\n       cat=rep(\"cds\",\n               length(length_cds)))\n)\n\nggplot(all_length,\n       aes(x=??, color=??)) +\n  geom_density() +\n  scale_x_log10(breaks = trans_breaks(\"log10\",\n                                      function(x) 10^x),\n                labels = trans_format(\"log10\",\n                                      math_format(10^.x))) +\n  theme_cowplot()\n```\n:::\n\n\nThe typical* human intron is way longer than a CDS exon. \n\n## ELAVL1/HuR {.smaller .nonincremental}\n\nELAVL1/HuR is an essential RNA-binding protein (RBP). \n\nHuR binds to AU-rich elements (ARE) in 3â€™ UTRs of mRNAs to promote mRNA stability.\n\n![](/img/block-rna/hur_mechanism.png)\n\n\nThis model makes a few specific prediction:  \n\n1. HuR binds  to the 3' UTR.  \n2. HuR binds to AU-rich sequences (AUUUA).  \n3. HuR binding promotes target RNA stabilization (and binding by the other RBPs to the ARE promotes destabilization).  \n\nWe will explore these predictions during the next couple classes.\n\n## PAR-CLIP data {.smaller}  \n\nReminder that we will be using this resource:\n[rag-tag ENCODE](https://github.com/BIMSBbioinfo/RCAS_meta-analysis)\n\nWe are looking for an ELAVL1 PAR-CLIP corresponding to this SRA (short-read archive) ID: **SRR248532**\n\n\n\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nhur_regions <- read_regions(con = \"https://raw.githubusercontent.com/BIMSBbioinfo/RCAS_meta-analysis/master/rbp-binding-sites/??.clusters.bed\",\n                            genome = 'hg19',\n                            format = '??')\n\n\n\n# looks like there are 111236 binding sites!!!\n# we are only going to keep those w/a score > 1\n# this will reduce it down to ~20K sites\n# the score reflects the frequency of T->C conversions vs no conversion and non-T->C conversions per binding site\nhur_regions <- hur_regions[hur_regions$score > 1]\n\nhur_regions\n```\n:::\n\n\n\n## Annotate PAR-CLIP data {.smaller}  \n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n# let's annotate\nhur_annot <- annotate_regions(\n    regions = ??,\n    annotations = annotations,\n    ignore.strand = FALSE,\n    quiet = FALSE) %>%\n  data.frame()\n  \n\n# we put in ~20K and got ~50K??\n\n# redundant info due to transcript_id\n\n# keep only columns we need\nmyInfo <- c(\"seqnames\",\"start\",\"end\",\"width\",\"strand\",\"annot.symbol\",\"annot.type\")\n\nhur_annot <- hur_annot[,??] %>%\n  unique() \n\n# getting rid of the \"hg19_genes_\" string to simplify `annot.type`\nhur_annot$annot.type <- gsub(\"hg19_genes_\",\"\",hur_annot$annot.type)\n\ntable()\n```\n:::\n\n\n\n## HuR binding region preference {.smaller}\n\nIt looks like HuR prefers binding to 3' UTRs and introns. That is a bit of a surprise given the model above indicating 3' UTR binding. Well let's take a step back and frame our expectation using what we know about the genome.\n\nFor example, how much of the genome is coding?\n\nIn this case, how many basepairs are introns and 3' UTRs in the genome?\n\n## binding region length biases {.smaller}\n\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n# total intron length\n# sum(\n#   width(\n#     GenomicRanges::reduce(\n#       annotations[annotations$type %in% my_hg19_annots[3]]\n#       )\n#     )\n#   )\n\nmylengths <- vector()\n\nfor (i in 1:length(my_hg19_annots)) {\n  mylengths[i] <- sum(width(GenomicRanges::reduce(annotations[annotations$type %in% my_hg19_annots[i]])))\n  \n  names(mylengths)[i] <- gsub(\"hg19_genes_\",\"\",my_hg19_annots[i])\n  \n  \n}\n\nbarplot(mylengths[1:4], las=2, main = \"total bases per category\", log=\"y\")\n```\n:::\n\n\n\n## Control for CLIP-binding sites {.smaller}\n\nWe need a way to figure out a null model OR background expectation.\n\nWhat if we were to take our HuR binding and randomize their position and then repeat the annotation on the randomized binding sites? \n\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n# randomize regions based on par-clip regions\nrandom_sites <- ??(\n  regions = hur_regions,\n  allow.overlaps = TRUE,\n  per.chromosome = TRUE)\n\n# annotate  randomize regions\nrandom_sites_annot <- annotate_regions(\n  regions = ??,\n  annotations = annotations,\n  ignore.strand = FALSE,\n  quiet = FALSE) %>%\n  data.frame()\n\n# select cols, keep unique\nrandom_sites_annot <- random_sites_annot[,myInfo] %>%\n  unique() \n\n# clean names\nrandom_sites_annot$annot.type <- gsub(\"hg19_genes_\",\"\",random_sites_annot$annot.type)\n\n\ntable(random_sites_annot$annot.type)\n```\n:::\n\n\n## Compare HuR vs Random {.smaller}\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\n# create a new tibble with the annotation counts for hur (observed) and random (expected) binding sties\nsite_dist <- bind_cols(\n  region=names(table(hur_annot$annot.type)),\n  observed=table(??$annot.type),\n  expected=table(??$annot.type)\n          ) %>%\n  mutate(enrichment = observed/expected) # calculate enrichment\n\n\nsite_dist_long <- pivot_longer(site_dist,\n                               cols = c(??,??,??)\n                               )\n\ncolnames(site_dist_long) <- c(\"region\",\"type\",\"value\")\n\n# plot counts for parclip vs random barplot\n# ggplot(site_dist_long %>% filter(type!=\"enrichment\"),\n#        aes(y = value, x = region, fill = type)) +\n#   geom_bar(stat=\"identity\", position=position_dodge()) +\n#   scale_fill_manual(values=c(\"black\",\"red\")) +\n#   theme_cowplot()\n\n# plot enrichment barplot\nggplot(site_dist_long %>% filter(type==\"??\"),\n       aes(y = ??,\n           x = ??)) +\n  geom_bar(stat=\"identity\") +\n  ylab(\"Observed vs Expected\") +\n  theme_cowplot()\n```\n:::\n\n\n\n\n## 5 MINUTE BREAK \n\n## What sequence does HuR bind to? {.smaller}\n\nIs it just *AUUUA*?\n\n**Different transcript regions have different nucleotide composition.**\n\n- 5' UTRs are more GC-rich  \n\n- 3' UTRs are more AU-rich  \n\n![](/img/block-rna/gc.jpg)\n\nWe need to account for these differences when asking what the binding preferences are for sites in a given transcript region.\n\n## Counting k-mers {.smaller}\n\nSteps to determine k-mer composition (we use 6mers) for any set of intervals\n\nWe'll do it for both HuR binding sites and then compare it to background seqs.\n\n1. Create a `Granges` object for a given annotation category.  \n2. Remove duplicated intervals (from diff transcript  ids) with `reduce`.   \n3. Retrieve seqeunces using  `getSeqs`\n4. Create a dataframe containing the count and frequency of each 6mer.\n\n\n## Calculate 6mers in HuR sites   {.smaller}\n\nSince HuR preferentially binds to 3' UTRs, that is the region we will focus on.\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\n# create a Grange for 3' UTRs \nhur_3utr <- makeGRangesFromDataFrame(\n  df = hur_annot %>% filter(??==\"??\"),\n  ignore.strand = F,\n  seqnames.field = \"seqnames\",\n  start.field = \"start\",\n  end.field = \"end\",\n  strand.field = \"strand\",\n  keep.extra.columns = T\n  )\n\n# get  sequencees for those coordinates\nhur_3utr_seqs <- getSeq(BSgenome.Hsapiens.UCSC.hg19, ??)\n\n# count  all 6 mer instances per sequence, add all instances, and turn into a dataframe with column name counts\nhur_utr3_6mer <- ??(\n  x = ??,\n  width = 6, # k\n  as.prob = F,\n  simplify.as=\"matrix\") %>%\n  colSums(.) %>%\n  as.data.frame()\n\ncolnames(hur_utr3_6mer) <- \"hur_utr_count\"\n\n# calc freq \nhur_utr3_6mer$hur_utr_freq <- hur_utr3_6mer$hur_utr_count/sum(hur_utr3_6mer$hur_utr_count)\n```\n:::\n\n\n\n## Calculate 6mers in 3utrs   {.smaller}\n\nNext, we will calculate 6mer frequencies in 3' UTRs. This will serve as a null model or background that we can compare with the HuR  binding  site 6mers. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a Grange for 3' UTRs \nthreeUTR <- GenomicRanges::reduce(annotations[annotations$type %in% my_hg19_annots[??]])\n\n# get sequences for those coordinates\nthreeUTR_seqs <- getSeq(BSgenome.Hsapiens.UCSC.hg19, threeUTR)\n\n# count  all 6 mer instances per sequence, add all instances, and turn into a dataframe with column name counts\nutr3_6mer <- ??(\n  x = ??,\n  width = 6,\n  as.prob = F,\n  simplify.as=\"matrix\") %>%\n  colSums(.) %>%\n  as.data.frame()\n\ncolnames(utr3_6mer) <- \"utr_count\"\n\n# calc freq\nutr3_6mer$utr_freq <- utr3_6mer$utr_count/sum(utr3_6mer$utr_count)\n```\n:::\n\n\n## Sequences enriched in hur sites vs 3utr {.smaller}  \n\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\n# check if rownames are identical and stop if they are  not\nstopifnot(identical(rownames(hur_utr3_6mer),rownames(utr3_6mer)))\n\n# bind_cols\nutr3_df <- bind_cols(hur_utr3_6mer,\n                     utr3_6mer)\n# Calc enrichment\nutr3_df$hur_enrich <- utr3_df$hur_utr_freq/utr3_df$utr_freq\n\n\n# plot coloring and labeling all > 8 fold enriched\nggplot(data = utr3_df,\n       aes(y = ??, # hur\n           x = ?? # utrs\n             )\n       ) +\n  geom_point(color = ifelse(utr3_df$hur_enrich > 8, \"red\", \"black\")) +\n  ylab(\"kmers: HuR 3'UTR sites\") +\n  xlab(\"kmers: 3'UTR\") +\n  geom_abline(intercept = 0, slope = 1) +\n  geom_text_repel(aes(label=ifelse(hur_enrich > 8,\n                                   rownames(utr3_df),\n                                   \"\"))) +\n  theme_cowplot()\n```\n:::\n\n\n\n## Sequences enriched in hur sites vs 3utr {.smaller}  \n\nNot just AU-rich...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutr3_df %>%\n  rownames_to_column(var = \"6mer\") %>%\n  arrange(-hur_enrich) %>%\n  gt() \n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}